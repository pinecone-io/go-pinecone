using module mode; GOMOD=/Users/audrey.lorberfeld/Desktop/src/go-pinecone/go.mod
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>pinecone - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.22.4";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package pinecone
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/pinecone-io/go-pinecone/pinecone"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package pinecone provides a client for the <a href="https://www.pinecone.io/">Pinecone managed vector database</a>.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="#Client">type Client</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewClient">func NewClient(in NewClientParams) (*Client, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewClientBase">func NewClientBase(in NewClientBaseParams) (*Client, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.ConfigureIndex">func (c *Client) ConfigureIndex(ctx context.Context, name string, podType *string, replicas *int32) (*Index, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.CreateCollection">func (c *Client) CreateCollection(ctx context.Context, in *CreateCollectionRequest) (*Collection, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.CreatePodIndex">func (c *Client) CreatePodIndex(ctx context.Context, in *CreatePodIndexRequest) (*Index, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.CreateServerlessIndex">func (c *Client) CreateServerlessIndex(ctx context.Context, in *CreateServerlessIndexRequest) (*Index, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.DeleteCollection">func (c *Client) DeleteCollection(ctx context.Context, collectionName string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.DeleteIndex">func (c *Client) DeleteIndex(ctx context.Context, idxName string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.DescribeCollection">func (c *Client) DescribeCollection(ctx context.Context, collectionName string) (*Collection, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.DescribeIndex">func (c *Client) DescribeIndex(ctx context.Context, idxName string) (*Index, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.Index">func (c *Client) Index(in NewIndexConnParams, dialOpts ...grpc.DialOption) (*IndexConnection, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.ListCollections">func (c *Client) ListCollections(ctx context.Context) ([]*Collection, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client.ListIndexes">func (c *Client) ListIndexes(ctx context.Context) ([]*Index, error)</a></dd>
				
			
				
				<dd><a href="#Cloud">type Cloud</a></dd>
				
				
			
				
				<dd><a href="#Collection">type Collection</a></dd>
				
				
			
				
				<dd><a href="#CollectionStatus">type CollectionStatus</a></dd>
				
				
			
				
				<dd><a href="#CreateCollectionRequest">type CreateCollectionRequest</a></dd>
				
				
			
				
				<dd><a href="#CreatePodIndexRequest">type CreatePodIndexRequest</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CreatePodIndexRequest.ReplicaCount">func (req CreatePodIndexRequest) ReplicaCount() *int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CreatePodIndexRequest.ShardCount">func (req CreatePodIndexRequest) ShardCount() *int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CreatePodIndexRequest.TotalCount">func (req CreatePodIndexRequest) TotalCount() *int</a></dd>
				
			
				
				<dd><a href="#CreateServerlessIndexRequest">type CreateServerlessIndexRequest</a></dd>
				
				
			
				
				<dd><a href="#DescribeIndexStatsResponse">type DescribeIndexStatsResponse</a></dd>
				
				
			
				
				<dd><a href="#FetchVectorsResponse">type FetchVectorsResponse</a></dd>
				
				
			
				
				<dd><a href="#Index">type Index</a></dd>
				
				
			
				
				<dd><a href="#IndexConnection">type IndexConnection</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.Close">func (idx *IndexConnection) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.DeleteAllVectorsInNamespace">func (idx *IndexConnection) DeleteAllVectorsInNamespace(ctx context.Context) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.DeleteVectorsByFilter">func (idx *IndexConnection) DeleteVectorsByFilter(ctx context.Context, filter *MetadataFilter) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.DeleteVectorsById">func (idx *IndexConnection) DeleteVectorsById(ctx context.Context, ids []string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.DescribeIndexStats">func (idx *IndexConnection) DescribeIndexStats(ctx context.Context) (*DescribeIndexStatsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.DescribeIndexStatsFiltered">func (idx *IndexConnection) DescribeIndexStatsFiltered(ctx context.Context, filter *MetadataFilter) (*DescribeIndexStatsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.FetchVectors">func (idx *IndexConnection) FetchVectors(ctx context.Context, ids []string) (*FetchVectorsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.ListVectors">func (idx *IndexConnection) ListVectors(ctx context.Context, in *ListVectorsRequest) (*ListVectorsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.QueryByVectorId">func (idx *IndexConnection) QueryByVectorId(ctx context.Context, in *QueryByVectorIdRequest) (*QueryVectorsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.QueryByVectorValues">func (idx *IndexConnection) QueryByVectorValues(ctx context.Context, in *QueryByVectorValuesRequest) (*QueryVectorsResponse, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.UpdateVector">func (idx *IndexConnection) UpdateVector(ctx context.Context, in *UpdateVectorRequest) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexConnection.UpsertVectors">func (idx *IndexConnection) UpsertVectors(ctx context.Context, in []*Vector) (uint32, error)</a></dd>
				
			
				
				<dd><a href="#IndexMetric">type IndexMetric</a></dd>
				
				
			
				
				<dd><a href="#IndexSpec">type IndexSpec</a></dd>
				
				
			
				
				<dd><a href="#IndexStatus">type IndexStatus</a></dd>
				
				
			
				
				<dd><a href="#IndexStatusState">type IndexStatusState</a></dd>
				
				
			
				
				<dd><a href="#ListVectorsRequest">type ListVectorsRequest</a></dd>
				
				
			
				
				<dd><a href="#ListVectorsResponse">type ListVectorsResponse</a></dd>
				
				
			
				
				<dd><a href="#Metadata">type Metadata</a></dd>
				
				
			
				
				<dd><a href="#MetadataFilter">type MetadataFilter</a></dd>
				
				
			
				
				<dd><a href="#NamespaceSummary">type NamespaceSummary</a></dd>
				
				
			
				
				<dd><a href="#NewClientBaseParams">type NewClientBaseParams</a></dd>
				
				
			
				
				<dd><a href="#NewClientParams">type NewClientParams</a></dd>
				
				
			
				
				<dd><a href="#NewIndexConnParams">type NewIndexConnParams</a></dd>
				
				
			
				
				<dd><a href="#PineconeError">type PineconeError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PineconeError.Error">func (pe *PineconeError) Error() string</a></dd>
				
			
				
				<dd><a href="#PodSpec">type PodSpec</a></dd>
				
				
			
				
				<dd><a href="#PodSpecMetadataConfig">type PodSpecMetadataConfig</a></dd>
				
				
			
				
				<dd><a href="#QueryByVectorIdRequest">type QueryByVectorIdRequest</a></dd>
				
				
			
				
				<dd><a href="#QueryByVectorValuesRequest">type QueryByVectorValuesRequest</a></dd>
				
				
			
				
				<dd><a href="#QueryVectorsResponse">type QueryVectorsResponse</a></dd>
				
				
			
				
				<dd><a href="#ScoredVector">type ScoredVector</a></dd>
				
				
			
				
				<dd><a href="#ServerlessSpec">type ServerlessSpec</a></dd>
				
				
			
				
				<dd><a href="#SparseValues">type SparseValues</a></dd>
				
				
			
				
				<dd><a href="#UpdateVectorRequest">type UpdateVectorRequest</a></dd>
				
				
			
				
				<dd><a href="#Usage">type Usage</a></dd>
				
				
			
				
				<dd><a href="#Vector">type Vector</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go">client.go</a>
			
				<a href="/src/github.com/pinecone-io/go-pinecone/pinecone/errors.go">errors.go</a>
			
				<a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go">index_connection.go</a>
			
				<a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go">models.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
		
			
			
			<h2 id="Client">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=2751:2850#L59">Client</a>
				<a class="permalink" href="#Client">&#xb6;</a>
				
				
			</h2>
			<p>Client holds the parameters for connecting to the Pinecone service. It is returned by the NewClient and NewClientBase
functions. To use Client, first build the parameters of the request using NewClientParams (or NewClientBaseParams).
Then, pass those parameters into the NewClient (or NewClientBase) function to create a new Client object.
Once instantiated, you can use Client to execute control plane API requests (e.g. create an Index, list Indexes,
etc.). Read more about different control plane API routes at <a href="https://docs.pinecone.io/reference/api/control-plane/list_indexes">docs.pinecone.io/reference/api</a>.
<p>Note: Client methods are safe for concurrent use.
<p>Fields:
<ul>
<li>headers: An optional map of additional HTTP headers to include in each API request to the control plane,
provided through NewClientParams.Headers or NewClientBaseParams.Headers.
<li>restClient: Optional underlying *http.Client object used to communicate with the Pinecone control plane API,
provided through NewClientParams.RestClient or NewClientBaseParams.RestClient. If not provided,
a default client is created for you.
<li>sourceTag: An optional string used to help Pinecone attribute API activity, provided through NewClientParams.SourceTag
or NewClientBaseParams.SourceTag.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams) // --&gt; This creates a new Client object.
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)
    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    } else {
	       fmt.Printf(&quot;Successfully found the \&quot;%s\&quot; index!\n&quot;, idx.Name)
    }

    idxConnection, err := pc.Index(idx.Host)
    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    } else {
	       log.Println(&quot;IndexConnection created successfully!&quot;)
    }
</pre>

			<pre>type Client struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewClient">func <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=6635:6686#L145">NewClient</a>
					<a class="permalink" href="#NewClient">&#xb6;</a>
					
					
				</h3>
				<pre>func NewClient(in <a href="#NewClientParams">NewClientParams</a>) (*<a href="#Client">Client</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>NewClient creates and initializes a new instance of Client.
This function sets up the control plane client with the necessary configuration for authentication and communication.
<p>Parameters:
<ul>
<li>in: A NewClientParams object. See NewClientParams for more information.
</ul>
<p>Note: It is important to handle the error returned by this function to ensure that the
control plane client has been created successfully before attempting to make API calls.
<p>Returns a pointer to an initialized Client instance or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }
</pre>

				
				
			
				
				<h3 id="NewClientBase">func <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=8653:8712#L198">NewClientBase</a>
					<a class="permalink" href="#NewClientBase">&#xb6;</a>
					
					
				</h3>
				<pre>func NewClientBase(in <a href="#NewClientBaseParams">NewClientBaseParams</a>) (*<a href="#Client">Client</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>NewClientBase creates and initializes a new instance of Client with custom authentication headers.
<p>Parameters:
<ul>
<li>in: A NewClientBaseParams object that includes the necessary configuration for the control plane client. See
NewClientBaseParams for more information.
</ul>
<p>Notes:
<ul>
<li>It is important to handle the error returned by this function to ensure that the
control plane client has been created successfully before attempting to make API calls.
<li>A Pinecone API key is not requried when using NewClientBase.
</ul>
<p>Returns a pointer to an initialized Client instance or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientBaseParams{
        Headers: map[string]string{
            &quot;Authorization&quot;: &quot;Bearer &quot; + &quot;&lt;your JWT token&gt;&quot;
            &quot;X-Project-Id&quot;: &quot;&lt;Your Pinecone project ID&gt;&quot;
        },
        SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClientBase(clientParams)
	       if err != nil {
            log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
        } else {
	           fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }
</pre>

				
				
			

			
				
				<h3 id="Client.ConfigureIndex">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=29864:29980#L795">ConfigureIndex</a>
					<a class="permalink" href="#Client.ConfigureIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) ConfigureIndex(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, name <a href="/pkg/builtin/#string">string</a>, podType *<a href="/pkg/builtin/#string">string</a>,
    replicas *<a href="/pkg/builtin/#int32">int32</a>) (*<a href="#Index">Index</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ConfigureIndex is used to <a href="https://docs.pinecone.io/guides/indexes/configure-pod-based-indexes">scale a pods-based index</a> up or down by changing the size of the pods or the number of
replicas.
<p>Parameters:
<ul>
<li>name: The name of the index to configure.
<li>pods: (Optional) The pod size to scale the index to (e.g. for a &quot;p1&quot; pod type,
you could pass &quot;p1.x2&quot; to scale your index to the &quot;x2&quot; size,
or you could pass &quot;p1.x4&quot; to scale your index to the &quot;x4&quot; size, and
so forth.
<li>replicas: (Optional) The number of replicas to scale the index to.
This is capped by the maximum number of replicas allowed in your Pinecone project. To configure this number,
go to <a href="https://app.pinecone.io">app.pinecone.io</a>, select your project, and configure the maximum number of pods.
</ul>
<p>Note: You can only scale an index up, not down. If you want to scale an index down,
you must create a new index with the desired configuration.
<p>Returns a pointer to a configured Index object or an error.
<p>Example for a pods-based index originally configured with 1 &quot;p1&quot; pod of size &quot;x2&quot; and 1 replica:
<pre>// To scale the size of your pods from &quot;x2&quot; to &quot;x4&quot;:
 _, err := pc.ConfigureIndex(ctx, &quot;my-index&quot;, &quot;p1.x4&quot;, nil)
 if err != nil {
     fmt.Printf(&quot;Failed to configure index: %v\n&quot;, err)
 }

// To scale the number of replicas:
 _, err := pc.ConfigureIndex(ctx, &quot;my-index&quot;, nil, 4)
 if err != nil {
     fmt.Printf(&quot;Failed to configure index: %v\n&quot;, err)
 }

// To scale both the size of your pods and the number of replicas:
 _, err := pc.ConfigureIndex(ctx, &quot;my-index&quot;, &quot;p1.x4&quot;, 4)
 if err != nil {
     fmt.Printf(&quot;Failed to configure index: %v\n&quot;, err)
 }
</pre>

				
				
				
			
				
				<h3 id="Client.CreateCollection">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=37882:37986#L1037">CreateCollection</a>
					<a class="permalink" href="#Client.CreateCollection">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) CreateCollection(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#CreateCollectionRequest">CreateCollectionRequest</a>) (*<a href="#Collection">Collection</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>CreateCollection creates and initializes a new <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection</a> via the specified Client.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A pointer to a CreateCollectionRequest object.
</ul>
<p>Note: Collections are only available for pods-based Indexes.
<p>Returns a pointer to a Collection object or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    collection, err := pc.CreateCollection(ctx, &amp;pinecone.CreateCollectionRequest{
        Name:   &quot;my-collection&quot;,
        Source: &quot;my-source-index&quot;,
    })
    if err != nil {
	       log.Fatalf(&quot;Failed to create collection: %v&quot;, err)
    } else {
	       fmt.Printf(&quot;Successfully created collection \&quot;%s\&quot;.&quot;, collection.Name)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.CreatePodIndex">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=19208:19303#L490">CreatePodIndex</a>
					<a class="permalink" href="#Client.CreatePodIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) CreatePodIndex(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#CreatePodIndexRequest">CreatePodIndexRequest</a>) (*<a href="#Index">Index</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>CreatePodIndex creates and initializes a new pods-based Index via the specified Client.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A pointer to a CreatePodIndexRequest object. See CreatePodIndexRequest for more information.
</ul>
<p>Returns a pointer to an Index object or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    podIndexMetadata := &amp;pinecone.PodSpecMetadataConfig{
	       Indexed: &amp;[]string{&quot;title&quot;, &quot;description&quot;},
    }

    idx, err := pc.CreatePodIndex(ctx, &amp;pinecone.CreatePodIndexRequest{
        Name:        &quot;my-pod-index&quot;,
        Dimension:   3,
        Metric:      pinecone.Cosine,
        Environment: &quot;us-west1-gcp&quot;,
        PodType:     &quot;s1&quot;,
        MetadataConfig: podIndexMetadata,
    })

    if err != nil {
	       log.Fatalf(&quot;Failed to create pod index:&quot;, err)
    } else {
	       fmt.Printf(&quot;Successfully created pod index: %s&quot;, idx.Name)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.CreateServerlessIndex">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=24648:24757#L636">CreateServerlessIndex</a>
					<a class="permalink" href="#Client.CreateServerlessIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) CreateServerlessIndex(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#CreateServerlessIndexRequest">CreateServerlessIndexRequest</a>) (*<a href="#Index">Index</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>CreateServerlessIndex creates and initializes a new serverless Index via the specified Client.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A pointer to a CreateServerlessIndexRequest object. See CreateServerlessIndexRequest for more information.
</ul>
<p>Returns a pointer to an Index object or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    idx, err := pc.CreateServerlessIndex(ctx, &amp;pinecone.CreateServerlessIndexRequest{
        Name:    &quot;my-serverless-index&quot;,
        Dimension: 3,
        Metric:  pinecone.Cosine,
        Cloud:   pinecone.Aws,
        Region:  &quot;us-east-1&quot;,
    })

    if err != nil {
        log.Fatalf(&quot;Failed to create serverless index: %s&quot;, idx.Name)
    } else {
        fmt.Printf(&quot;Successfully created serverless index: %s&quot;, idx.Name)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.DeleteCollection">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=39584:39667#L1093">DeleteCollection</a>
					<a class="permalink" href="#Client.DeleteCollection">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) DeleteCollection(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, collectionName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>DeleteCollection deletes a specific <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection</a>
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>collectionName: The name of the Collection to delete.
</ul>
<p>Note: Collections are only available for pods-based Indexes.
<p>Returns an error if the deletion fails.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    collectionName := &quot;my-collection&quot;

    err = pc.DeleteCollection(ctx, collectionName)
    if err != nil {
	       log.Fatalf(&quot;Failed to create collection: %s\n&quot;, err)
    } else {
	       log.Printf(&quot;Successfully deleted collection \&quot;%s\&quot;\n&quot;, collectionName)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.DeleteIndex">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=27743:27814#L741">DeleteIndex</a>
					<a class="permalink" href="#Client.DeleteIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) DeleteIndex(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, idxName <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>DeleteIndex deletes a specific Index.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>idxName: The name of the Index to delete.
</ul>
<p>Returns an error if the deletion fails.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    indexName := &quot;the-name-of-my-index&quot;

    err = pc.DeleteIndex(ctx, indexName)
    if err != nil {
	       log.Fatalf(&quot;Error: %v&quot;, err)
    } else {
        fmt.Printf(&quot;Index \&quot;%s\&quot; deleted successfully&quot;, indexName)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.DescribeCollection">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=34805:34905#L943">DescribeCollection</a>
					<a class="permalink" href="#Client.DescribeCollection">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) DescribeCollection(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, collectionName <a href="/pkg/builtin/#string">string</a>) (*<a href="#Collection">Collection</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DescribeCollection retrieves information about a specific <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection</a>.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>collectionName: The name of the Collection to describe.
</ul>
<p>Returns a pointer to a Collection object or an error.
<p>Note: Collections are only available for pods-based Indexes.
<p>Since the returned value is a pointer to a Collection object, it will have the following fields:
<ul>
<li>Name: The name of the Collection.
<li>Size: The size of the Collection in bytes.
<li>Status: The status of the Collection.
<li>Dimension: The <a href="https://docs.pinecone.io/guides/indexes/choose-a-pod-type-and-size#dimensionality-of-vectors">dimensionality</a> of the vectors stored in each record held in the Collection.
<li>VectorCount: The number of records stored in the Collection.
<li>Environment: The cloud environment where the Collection is hosted.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    collection, err := pc.DescribeCollection(ctx, &quot;my-collection&quot;)
    if err != nil {
	       log.Fatalf(&quot;Error describing collection: %v&quot;, err)
    } else {
	       fmt.Printf(&quot;Collection: %+v\n&quot;, *collection)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.DescribeIndex">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=26379:26462#L694">DescribeIndex</a>
					<a class="permalink" href="#Client.DescribeIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) DescribeIndex(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, idxName <a href="/pkg/builtin/#string">string</a>) (*<a href="#Index">Index</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DescribeIndex retrieves information about a specific Index. See Index for more information.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
<li>idxName: The name of the Index to describe.
</ul>
<p>Returns a pointer to an Index object or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;the-name-of-my-index&quot;)
    if err != nil {
        log.Fatalf(&quot;Failed to describe index: %s&quot;, err)
    } else {
        fmt.Printf(&quot;%+v&quot;, *idx)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.Index">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=10961:11061#L267">Index</a>
					<a class="permalink" href="#Client.Index">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) Index(in <a href="#NewIndexConnParams">NewIndexConnParams</a>, dialOpts ...<a href="/pkg/google.golang.org/grpc/">grpc</a>.<a href="/pkg/google.golang.org/grpc/#DialOption">DialOption</a>) (*<a href="#IndexConnection">IndexConnection</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Index creates an IndexConnection to a specified host.
<p>Parameters:
<ul>
<li>in: A NewIndexConnParams object that includes the necessary configuration to create an IndexConnection.
See NewIndexConnParams for more information.
</ul>
<p>Note: It is important to handle the error returned by this method to ensure that the IndexConnection is created
successfully before making data plane calls.
<p>Returns a pointer to an IndexConnection instance or an error.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)
    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    } else {
	       fmt.Printf(&quot;Successfully found the \&quot;%s\&quot; index!\n&quot;, idx.Name)
    }

    indexConnParams := pinecone.NewIndexConnParams{
	       Host: idx.Host,
	       Namespace: &quot;your-namespace&quot;,
	       AdditionalMetadata: map[string]string{
		       &quot;your-metadata-key&quot;: &quot;your-metadata-value&quot;,
	       },
    }

    idxConnection, err := pc.Index(indexConnParams)
    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    } else {
	       log.Println(&quot;IndexConnection created successfully!&quot;)
    }
</pre>

				
				
				
			
				
				<h3 id="Client.ListCollections">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=32339:32415#L875">ListCollections</a>
					<a class="permalink" href="#Client.ListCollections">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) ListCollections(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) ([]*<a href="#Collection">Collection</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListCollections retrieves a list of all Collections in a Pinecone <a href="https://docs.pinecone.io/guides/projects/understanding-projects">project</a>. See Collection for more information.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
</ul>
<p>Returns a slice of pointers to <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection</a> objects or an error.
<p>Note: Collections are only available for pods-based Indexes.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    collections, err := pc.ListCollections(ctx)
    if err != nil {
	       log.Fatalf(&quot;Failed to list collections: %v&quot;, err)
    } else {
	       if len(collections) == 0 {
	           fmt.Printf(&quot;No collections found in project&quot;)
	       } else {
	           fmt.Println(&quot;Collections in project:&quot;)
	           for _, collection := range collections {
		           fmt.Printf(&quot;- %s\n&quot;, collection.Name)
	           }
	       }
    }
</pre>

				
				
				
			
				
				<h3 id="Client.ListIndexes">func (*Client) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=12820:12887#L324">ListIndexes</a>
					<a class="permalink" href="#Client.ListIndexes">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Client">Client</a>) ListIndexes(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) ([]*<a href="#Index">Index</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListIndexes retrieves a list of all Indexes in a Pinecone <a href="https://docs.pinecone.io/guides/projects/understanding-projects">project</a>.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime, allowing for the request
to be canceled or to timeout according to the context&apos;s deadline.
</ul>
<p>Returns a slice of pointers to Index objects or an error.
<p>Example:
<pre>    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    idxs, err := pc.ListIndexes(ctx)
    if err != nil {
	       log.Fatalf(&quot;Failed to list indexes: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Your project has the following indexes:&quot;)
	       for _, idx := range idxs {
		       fmt.Printf(&quot;- \&quot;%s\&quot;\n&quot;, idx.Name)
	       }
    }
</pre>

				
				
				
			
		
			
			
			<h2 id="Cloud">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=1280:1297#L23">Cloud</a>
				<a class="permalink" href="#Cloud">&#xb6;</a>
				
				
			</h2>
			<p>Cloud is the <a href="https://docs.pinecone.io/troubleshooting/available-cloud-regions">cloud provider</a> to be used for a Pinecone serverless Index.

			<pre>type Cloud <a href="/pkg/builtin/#string">string</a></pre>

			
				
				<pre>const (
    <span id="Aws">Aws</span>   <a href="#Cloud">Cloud</a> = &#34;aws&#34;
    <span id="Azure">Azure</span> <a href="#Cloud">Cloud</a> = &#34;azure&#34;
    <span id="Gcp">Gcp</span>   <a href="#Cloud">Cloud</a> = &#34;gcp&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Collection">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=2333:2645#L56">Collection</a>
				<a class="permalink" href="#Collection">&#xb6;</a>
				
				
			</h2>
			<p>Collection is a Pinecone <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection object</a>. Only available for pod-based Indexes.

			<pre>type Collection struct {
<span id="Collection.Name"></span>    Name        <a href="/pkg/builtin/#string">string</a>           `json:&#34;name&#34;`
<span id="Collection.Size"></span>    Size        <a href="/pkg/builtin/#int64">int64</a>            `json:&#34;size&#34;`
<span id="Collection.Status"></span>    Status      <a href="#CollectionStatus">CollectionStatus</a> `json:&#34;status&#34;`
<span id="Collection.Dimension"></span>    Dimension   <a href="/pkg/builtin/#int32">int32</a>            `json:&#34;dimension&#34;`
<span id="Collection.VectorCount"></span>    VectorCount <a href="/pkg/builtin/#int32">int32</a>            `json:&#34;vector_count&#34;`
<span id="Collection.Environment"></span>    Environment <a href="/pkg/builtin/#string">string</a>           `json:&#34;environment&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="CollectionStatus">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=2707:2735#L66">CollectionStatus</a>
				<a class="permalink" href="#CollectionStatus">&#xb6;</a>
				
				
			</h2>
			<p>CollectionStatus is the status of a Pinecone Collection.

			<pre>type CollectionStatus <a href="/pkg/builtin/#string">string</a></pre>

			
				
				<pre>const (
    <span id="CollectionStatusInitializing">CollectionStatusInitializing</span> <a href="#CollectionStatus">CollectionStatus</a> = &#34;Initializing&#34;
    <span id="CollectionStatusReady">CollectionStatusReady</span>        <a href="#CollectionStatus">CollectionStatus</a> = &#34;Ready&#34;
    <span id="CollectionStatusTerminating">CollectionStatusTerminating</span>  <a href="#CollectionStatus">CollectionStatus</a> = &#34;Terminating&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="CreateCollectionRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=36460:36529#L994">CreateCollectionRequest</a>
				<a class="permalink" href="#CreateCollectionRequest">&#xb6;</a>
				
				
			</h2>
			<p>CreateCollectionRequest holds the parameters for creating a new <a href="https://docs.pinecone.io/guides/indexes/understanding-collections">Collection</a>.
<p>Fields:
<ul>
<li>Name: The name of the Collection.
<li>Source: The name of the Index to be used as the source for the Collection.
</ul>
<p>To create a new Collection, use the CreateCollection method on the Client object.
<p>Note: Collections are only available for pods-based Indexes.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    collection, err := pc.CreateCollection(ctx, &amp;pinecone.CreateCollectionRequest{
        Name:   &quot;my-collection&quot;,
        Source: &quot;my-source-index&quot;,
     })
    if err != nil {
	       log.Fatalf(&quot;Failed to create collection: %v&quot;, err)
    } else {
	       fmt.Printf(&quot;Successfully created collection \&quot;%s\&quot;.&quot;, collection.Name)
    }
</pre>

			<pre>type CreateCollectionRequest struct {
<span id="CreateCollectionRequest.Name"></span>    Name   <a href="/pkg/builtin/#string">string</a>
<span id="CreateCollectionRequest.Source"></span>    Source <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="CreatePodIndexRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=16695:16976#L415">CreatePodIndexRequest</a>
				<a class="permalink" href="#CreatePodIndexRequest">&#xb6;</a>
				
				
			</h2>
			<p>CreatePodIndexRequest holds the parameters for creating a new pods-based Index.
<p>Fields:
<ul>
<li>Name: The name of the Index. Resource name must be 1-45 characters long,
start and end with an alphanumeric character,
and consist only of lower case alphanumeric characters or &apos;-&apos;.
<li>Dimension: The <a href="https://docs.pinecone.io/guides/indexes/choose-a-pod-type-and-size#dimensionality-of-vectors">dimensionality</a> of the vectors to be inserted in the Index.
<li>Metric: The distance metric to be used for <a href="https://docs.pinecone.io/guides/indexes/understanding-indexes#distance-metrics">similarity</a> search. You can use
&apos;euclidean&apos;, &apos;cosine&apos;, or &apos;dotproduct&apos;.
<li>Environment: The <a href="https://docs.pinecone.io/guides/indexes/understanding-indexes#pod-environments">cloud environment</a> where the Index will be hosted.
<li>PodType: The [type of pod] to use for the Index. One of `s1`, `p1`, or `p2` appended with `.` and
one of `x1`, `x2`, `x4`, or `x8`.
<li>Shards: The number of shards to use for the Index (defaults to 1).
Shards split your data across multiple pods, so you can fit more data into an Index.
<li>Replicas: The number of <a href="https://docs.pinecone.io/guides/indexes/configure-pod-based-indexes#add-replicas">replicas</a> to use for the Index (defaults to 1). Replicas duplicate your Index.
They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
<li>SourceCollection: The name of the Collection to be used as the source for the Index.
<li>MetadataConfig: The <a href="https://docs.pinecone.io/guides/indexes/configure-pod-based-indexes#selective-metadata-indexing">metadata configuration</a> for the behavior of Pinecone&apos;s internal metadata Index. By
default, all metadata is indexed; when `metadata_config` is present,
only specified metadata fields are indexed. These configurations are
only valid for use with pod-based Indexes.
</ul>
<p>To create a new pods-based Index, use the CreatePodIndex method on the Client object.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    podIndexMetadata := &amp;pinecone.PodSpecMetadataConfig{
	       Indexed: &amp;[]string{&quot;title&quot;, &quot;description&quot;},
    }

    idx, err := pc.CreatePodIndex(ctx, &amp;pinecone.CreatePodIndexRequest{
        Name:        &quot;my-pod-index&quot;,
        Dimension:   3,
        Metric:      pinecone.Cosine,
        Environment: &quot;us-west1-gcp&quot;,
        PodType:     &quot;s1&quot;,
        MetadataConfig: podIndexMetadata,
        })

    if err != nil {
	       log.Fatalf(&quot;Failed to create pod index: %v&quot;, err)
    } else {
	       fmt.Printf(&quot;Successfully created pod index: %s&quot;, idx.Name)
    }
</pre>

			<pre>type CreatePodIndexRequest struct {
<span id="CreatePodIndexRequest.Name"></span>    Name             <a href="/pkg/builtin/#string">string</a>
<span id="CreatePodIndexRequest.Dimension"></span>    Dimension        <a href="/pkg/builtin/#int32">int32</a>
<span id="CreatePodIndexRequest.Metric"></span>    Metric           <a href="#IndexMetric">IndexMetric</a>
<span id="CreatePodIndexRequest.Environment"></span>    Environment      <a href="/pkg/builtin/#string">string</a>
<span id="CreatePodIndexRequest.PodType"></span>    PodType          <a href="/pkg/builtin/#string">string</a>
<span id="CreatePodIndexRequest.Shards"></span>    Shards           <a href="/pkg/builtin/#int32">int32</a>
<span id="CreatePodIndexRequest.Replicas"></span>    Replicas         <a href="/pkg/builtin/#int32">int32</a>
<span id="CreatePodIndexRequest.SourceCollection"></span>    SourceCollection *<a href="/pkg/builtin/#string">string</a>
<span id="CreatePodIndexRequest.MetadataConfig"></span>    MetadataConfig   *<a href="#PodSpecMetadataConfig">PodSpecMetadataConfig</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CreatePodIndexRequest.ReplicaCount">func (CreatePodIndexRequest) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=17134:17188#L429">ReplicaCount</a>
					<a class="permalink" href="#CreatePodIndexRequest.ReplicaCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (req <a href="#CreatePodIndexRequest">CreatePodIndexRequest</a>) ReplicaCount() *<a href="/pkg/builtin/#int32">int32</a></pre>
				<p>ReplicaCount ensures the replica count of a pods-based Index is &gt;1.
It returns a pointer to the number of replicas on a CreatePodIndexRequest object.

				
				
				
			
				
				<h3 id="CreatePodIndexRequest.ShardCount">func (CreatePodIndexRequest) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=17387:17439#L436">ShardCount</a>
					<a class="permalink" href="#CreatePodIndexRequest.ShardCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (req <a href="#CreatePodIndexRequest">CreatePodIndexRequest</a>) ShardCount() *<a href="/pkg/builtin/#int32">int32</a></pre>
				<p>ShardCount ensures the number of shards on a pods-based Index is &gt;1. It returns a pointer to the number of shards on
a CreatePodIndexRequest object.

				
				
				
			
				
				<h3 id="CreatePodIndexRequest.TotalCount">func (CreatePodIndexRequest) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=17596:17646#L442">TotalCount</a>
					<a class="permalink" href="#CreatePodIndexRequest.TotalCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (req <a href="#CreatePodIndexRequest">CreatePodIndexRequest</a>) TotalCount() *<a href="/pkg/builtin/#int">int</a></pre>
				<p>TotalCount calculates and returns the total number of pods (replicas*shards) on a CreatePodIndexRequest object.

				
				
				
			
		
			
			
			<h2 id="CreateServerlessIndexRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=23136:23273#L590">CreateServerlessIndexRequest</a>
				<a class="permalink" href="#CreateServerlessIndexRequest">&#xb6;</a>
				
				
			</h2>
			<p>CreateServerlessIndexRequest holds the parameters for creating a new <a href="https://docs.pinecone.io/guides/indexes/understanding-indexes#serverless-indexes">Serverless</a> Index.
<p>Fields:
<ul>
<li>Name: The name of the Index. Resource name must be 1-45 characters long,
start and end with an alphanumeric character,
and consist only of lower case alphanumeric characters or &apos;-&apos;.
<li>Dimension: The <a href="https://docs.pinecone.io/guides/indexes/choose-a-pod-type-and-size#dimensionality-of-vectors">dimensionality</a> of the vectors to be inserted in the Index.
<li>Metric: The metric used to measure the <a href="https://docs.pinecone.io/guides/indexes/understanding-indexes#distance-metrics">similarity</a> between vectors (&apos;euclidean&apos;, &apos;cosine&apos;, or &apos;dotproduct&apos;).
<li>Cloud: The public <a href="https://docs.pinecone.io/troubleshooting/available-cloud-regions#regions-available-for-serverless-indexes">cloud provider</a> where you would like your Index hosted.
For serverless Indexes, you define only the cloud and region where the Index should be hosted.
<li>Region: The <a href="https://docs.pinecone.io/troubleshooting/available-cloud-regions">region</a> where you would like your Index to be created.
</ul>
<p>To create a new Serverless Index, use the CreateServerlessIndex method on the Client object.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)
    if err != nil {
        log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    } else {
	       fmt.Println(&quot;Successfully created a new Client object!&quot;)
    }

    idx, err := pc.CreateServerlessIndex(ctx, &amp;pinecone.CreateServerlessIndexRequest{
        Name:    &quot;my-serverless-index&quot;,
        Dimension: 3,
        Metric:  pinecone.Cosine,
        Cloud:   pinecone.Aws,
        Region:  &quot;us-east-1&quot;,
    })

    if err != nil {
        log.Fatalf(&quot;Failed to create serverless index: %s&quot;, idx.Name)
    } else {
        fmt.Printf(&quot;Successfully created serverless index: %s&quot;, idx.Name)
    }
</pre>

			<pre>type CreateServerlessIndexRequest struct {
<span id="CreateServerlessIndexRequest.Name"></span>    Name      <a href="/pkg/builtin/#string">string</a>
<span id="CreateServerlessIndexRequest.Dimension"></span>    Dimension <a href="/pkg/builtin/#int32">int32</a>
<span id="CreateServerlessIndexRequest.Metric"></span>    Metric    <a href="#IndexMetric">IndexMetric</a>
<span id="CreateServerlessIndexRequest.Cloud"></span>    Cloud     <a href="#Cloud">Cloud</a>
<span id="CreateServerlessIndexRequest.Region"></span>    Region    <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="DescribeIndexStatsResponse">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=27172:27503#L836">DescribeIndexStatsResponse</a>
				<a class="permalink" href="#DescribeIndexStatsResponse">&#xb6;</a>
				
				
			</h2>
			<p>DescribeIndexStatsResponse holds the parameters for the DescribeIndexStatsResponse object,
which is returned by the DescribeIndexStats method.
<p>Fields:
<ul>
<li>Dimension: The dimension of the index.
<li>IndexFullness: The fullness level of the index. Note: only available on pods-based indexes.
<li>TotalVectorCount: The total number of vectors in the index.
<li>Namespaces: The namespace(s) in the index.
</ul>

			<pre>type DescribeIndexStatsResponse struct {
<span id="DescribeIndexStatsResponse.Dimension"></span>    Dimension        <a href="/pkg/builtin/#uint32">uint32</a>                       `json:&#34;dimension&#34;`
<span id="DescribeIndexStatsResponse.IndexFullness"></span>    IndexFullness    <a href="/pkg/builtin/#float32">float32</a>                      `json:&#34;index_fullness&#34;`
<span id="DescribeIndexStatsResponse.TotalVectorCount"></span>    TotalVectorCount <a href="/pkg/builtin/#uint32">uint32</a>                       `json:&#34;total_vector_count&#34;`
<span id="DescribeIndexStatsResponse.Namespaces"></span>    Namespaces       map[<a href="/pkg/builtin/#string">string</a>]*<a href="#NamespaceSummary">NamespaceSummary</a> `json:&#34;namespaces,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="FetchVectorsResponse">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=5606:5750#L193">FetchVectorsResponse</a>
				<a class="permalink" href="#FetchVectorsResponse">&#xb6;</a>
				
				
			</h2>
			<p>FetchVectorsResponse holds the parameters for the FetchVectorsResponse object,
which is returned by the FetchVectors method.
<p>Fields:
<ul>
<li>Vectors: The vectors fetched.
<li>Usage: The usage information for the request.
</ul>

			<pre>type FetchVectorsResponse struct {
<span id="FetchVectorsResponse.Vectors"></span>    Vectors map[<a href="/pkg/builtin/#string">string</a>]*<a href="#Vector">Vector</a> `json:&#34;vectors,omitempty&#34;`
<span id="FetchVectorsResponse.Usage"></span>    Usage   *<a href="#Usage">Usage</a>             `json:&#34;usage,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Index">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=1873:2151#L44">Index</a>
				<a class="permalink" href="#Index">&#xb6;</a>
				
				
			</h2>
			<p>Index is a Pinecone Index object. Can be either a pod-based or a serverless Index, depending on the IndexSpec.

			<pre>type Index struct {
<span id="Index.Name"></span>    Name      <a href="/pkg/builtin/#string">string</a>       `json:&#34;name&#34;`
<span id="Index.Dimension"></span>    Dimension <a href="/pkg/builtin/#int32">int32</a>        `json:&#34;dimension&#34;`
<span id="Index.Host"></span>    Host      <a href="/pkg/builtin/#string">string</a>       `json:&#34;host&#34;`
<span id="Index.Metric"></span>    Metric    <a href="#IndexMetric">IndexMetric</a>  `json:&#34;metric&#34;`
<span id="Index.Spec"></span>    Spec      *<a href="#IndexSpec">IndexSpec</a>   `json:&#34;spec,omitempty&#34;`
<span id="Index.Status"></span>    Status    *<a href="#IndexStatus">IndexStatus</a> `json:&#34;status,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="IndexConnection">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=618:797#L13">IndexConnection</a>
				<a class="permalink" href="#IndexConnection">&#xb6;</a>
				
				
			</h2>
			<p>IndexConnection holds the parameters for a Pinecone IndexConnection object.
<p>Fields:
<ul>
<li>Namespace: The namespace where index operations will be performed.
<li>additionalMetadata: Additional metadata to be sent with each RPC request.
<li>dataClient: The gRPC client for the index.
<li>grpcConn: The gRPC connection.
</ul>

			<pre>type IndexConnection struct {
<span id="IndexConnection.Namespace"></span>    Namespace <a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="IndexConnection.Close">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=2886:2927#L97">Close</a>
					<a class="permalink" href="#IndexConnection.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the grpc.ClientConn to a Pinecone index.
<p>Returns an error if the connection cannot be closed, otherwise returns nil.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection: %v&quot;, err)
    }

    err = idxConnection.Close()

    if err != nil {
	       log.Fatalf(&quot;Failed to close index connection. Error: %v&quot;, err)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.DeleteAllVectorsInNamespace">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=24202:24284#L745">DeleteAllVectorsInNamespace</a>
					<a class="permalink" href="#IndexConnection.DeleteAllVectorsInNamespace">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) DeleteAllVectorsInNamespace(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>DeleteAllVectorsInNamespace deletes all vectors in a specific namespace.
<p>Returns an error if the request fails, otherwise returns nil.
<p>Note: You must instantiate an IndexWithNamespace connection in order to delete vectors by ID in namespaces other
than the default.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    err = idxConnection.DeleteAllVectorsInNamespace(ctx)

    if err != nil {
	       log.Fatalf(&quot;Failed to delete vectors in namespace: \&quot;%s\&quot;. Error: %s&quot;, idxConnection.Namespace, err)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.DeleteVectorsByFilter">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=22548:22648#L693">DeleteVectorsByFilter</a>
					<a class="permalink" href="#IndexConnection.DeleteVectorsByFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) DeleteVectorsByFilter(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, filter *<a href="#MetadataFilter">MetadataFilter</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>DeleteVectorsByFilter deletes vectors from a Pinecone index, given a filter.
<p>Returns an error if the request fails, otherwise returns nil.
<p>Note: DeleteVectorsByFilter is only available on pods-based indexes.
Additionally, you must instantiate an IndexWithNamespace connection in order to delete vectors in namespaces
other than the default.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>filter: The filter to apply to the deletion.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	        log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    metadataFilter := map[string]interface{}{
	       &quot;genre&quot;: &quot;classical&quot;,
    }

    filter, err := structpb.NewStruct(metadataFilter)

    if err != nil {
	       log.Fatalf(&quot;Failed to create metadata filter. Error: %v&quot;, err)
    }

    err = idxConnection.DeleteVectorsByFilter(ctx, filter)

    if err != nil {
	       log.Fatalf(&quot;Failed to delete vector(s) with filter: %+v. Error: %s\n&quot;, filter, err)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.DeleteVectorsById">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=20532:20618#L629">DeleteVectorsById</a>
					<a class="permalink" href="#IndexConnection.DeleteVectorsById">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) DeleteVectorsById(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, ids []<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>DeleteVectorsById deletes vectors by ID from a Pinecone index.
<p>Returns an error if the request fails,
otherwise returns nil. This method will also return nil if the passed vector ID does not exist in the index or
namespace.
<p>Note: You must instantiate an IndexWithNamespace connection in order to delete vectors by ID in namespaces other
than the default.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>ids: IDs of the vectors you want to delete.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host, Namespace: &quot;custom-namespace&quot;})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    vectorId := &quot;your-vector-id&quot;
    err = idxConnection.DeleteVectorsById(ctx, []string{vectorId})

    if err != nil {
	       log.Fatalf(&quot;Failed to delete vector with ID: %s. Error: %s\n&quot;, vectorId, err)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.DescribeIndexStats">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=28813:28917#L885">DescribeIndexStats</a>
					<a class="permalink" href="#IndexConnection.DescribeIndexStats">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) DescribeIndexStats(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) (*<a href="#DescribeIndexStatsResponse">DescribeIndexStatsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DescribeIndexStats returns statistics about a Pinecone index.
<p>Returns a pointer to a DescribeIndexStatsResponse object or an error if the request fails.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index:&quot;, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    res, err := idxConnection.DescribeIndexStats(ctx)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error: %s&quot;, idx.Name, err)
    } else {
	       log.Fatalf(&quot;%+v&quot;, *res)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.DescribeIndexStatsFiltered">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=30915:31051#L946">DescribeIndexStatsFiltered</a>
					<a class="permalink" href="#IndexConnection.DescribeIndexStatsFiltered">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) DescribeIndexStatsFiltered(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, filter *<a href="#MetadataFilter">MetadataFilter</a>) (*<a href="#DescribeIndexStatsResponse">DescribeIndexStatsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DescribeIndexStatsFiltered returns statistics about a Pinecone index, filtered by a given filter.
<p>Returns a pointer to a DescribeIndexStatsResponse object or an error if the request fails.
<p>Note: DescribeIndexStatsFiltered is only available on pods-based indexes.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>filter: The filter to apply to the request.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    metadataFilter := map[string]interface{}{
	       &quot;genre&quot;: &quot;classical&quot;,
    }

    filter, err := structpb.NewStruct(metadataFilter)

    if err != nil {
	       log.Fatalf(&quot;Failed to create filter %+v. Error: %s&quot;, metadataFilter, err)
    }

    res, err := idxConnection.DescribeIndexStatsFiltered(ctx, filter)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error: %s&quot;, idx.Name, err)
    } else {
	       for name, summary := range res.Namespaces {
		       fmt.Printf(&quot;Namespace: \&quot;%s\&quot;, has %d vector(s) that match the given filter\n&quot;, name, summary.VectorCount)
	       }
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.FetchVectors">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=7196:7302#L245">FetchVectors</a>
					<a class="permalink" href="#IndexConnection.FetchVectors">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) FetchVectors(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, ids []<a href="/pkg/builtin/#string">string</a>) (*<a href="#FetchVectorsResponse">FetchVectorsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>FetchVectors fetches vectors by ID from a Pinecone index.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>ids: The unique IDs of the vectors to fetch.
</ul>
<p>Returns a pointer to any fetched vectors or an error if the request fails.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    res, err := idxConnection.FetchVectors(ctx, []string{&quot;abc-1&quot;})

    if err != nil {
	       log.Fatalf(&quot;Failed to fetch vectors, error: %+v&quot;, err)
    }

    if len(res.Vectors) != 0 {
	       fmt.Println(res)
    } else {
	       fmt.Println(&quot;No vectors found&quot;)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.ListVectors">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=10652:10766#L350">ListVectors</a>
					<a class="permalink" href="#IndexConnection.ListVectors">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) ListVectors(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#ListVectorsRequest">ListVectorsRequest</a>) (*<a href="#ListVectorsResponse">ListVectorsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListVectors lists vectors in a Pinecone index. You can filter vectors by prefix,
limit the number of vectors returned, and paginate through results.
<p>Note: ListVectors is only available for Serverless indexes.
<p>Returns a pointer to a ListVectorsResponse object or an error if the request fails.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A ListVectorsRequest object with the parameters for the request.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    prefix := &quot;abc&quot;
    limit := uint32(10)

    res, err := idxConnection.ListVectors(ctx, &amp;pinecone.ListVectorsRequest{
	       Prefix: &amp;prefix,
	       Limit:  &amp;limit,
    })

    if err != nil {
	       log.Fatalf(&quot;Failed to list vectors in index: %s. Error: %s\n&quot;, idx.Name, err)
    }

    if len(res.VectorIds) == 0 {
	       fmt.Println(&quot;No vectors found&quot;)
    } else {
	       fmt.Printf(&quot;Found %d vector(s)\n&quot;, len(res.VectorIds))
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.QueryByVectorId">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=18453:18576#L568">QueryByVectorId</a>
					<a class="permalink" href="#IndexConnection.QueryByVectorId">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) QueryByVectorId(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#QueryByVectorIdRequest">QueryByVectorIdRequest</a>) (*<a href="#QueryVectorsResponse">QueryVectorsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryByVectorId uses a vector ID to query a Pinecone index and retrieve vectors that are most similar to the
provided ID&apos;s underlying vector.
<p>Returns a pointer to a QueryVectorsResponse object or an error if the request fails.
<p>Note: QueryByVectorId executes a nearest neighbors search,
meaning that unless TopK=1 in the QueryByVectorIdRequest object,
it will return 2+ vectors. The vector with a score of 1.0 is the vector with the same ID as the query vector.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A QueryByVectorIdRequest object with the parameters for the request.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    vectorId := &quot;abc-1&quot;
    topK := uint32(10)

    res, err := idxConnection.QueryByVectorId(ctx, &amp;pinecone.QueryByVectorIdRequest{
	       VectorId:        vectorId,
	       TopK:            topK, // number of vectors you want returned
	       IncludeValues:   true,
	       IncludeMetadata: true,
    })

    if err != nil {
	       log.Fatalf(&quot;Error encountered when querying by vector ID `%s`. Error: %s&quot;, vectorId, err)
    } else {
	       for _, match := range res.Matches {
		       fmt.Printf(&quot;Match vector with ID `%s`, with score %f\n&quot;, match.Vector.Id, match.Score)
	       }
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.QueryByVectorValues">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=15063:15194#L477">QueryByVectorValues</a>
					<a class="permalink" href="#IndexConnection.QueryByVectorValues">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) QueryByVectorValues(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#QueryByVectorValuesRequest">QueryByVectorValuesRequest</a>) (*<a href="#QueryVectorsResponse">QueryVectorsResponse</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryByVectorValues queries a Pinecone index for vectors that are most similar to a provided query vector.
<p>Returns a pointer to a QueryVectorsResponse object or an error if the request fails.
<p>Note: To issue a hybrid query with both dense and sparse values,
your index&apos;s similarity metric must be dot-product.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>in: A QueryByVectorValuesRequest object with the parameters for the request.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    queryVector := []float32{1.0, 2.0}
    topK := uint32(10)

    metadataMap := map[string]interface{}{
	       &quot;genre&quot;: &quot;classical&quot;,
    }

    metadataFilter, err := structpb.NewStruct(metadataMap)

    if err != nil {
	       log.Fatalf(&quot;Failed to create metadata map. Error: %v&quot;, err)
    }

    sparseValues := pinecone.SparseValues{
	       Indices: []uint32{0, 1},
	       Values:  []float32{1.0, 2.0},
    }

    res, err := idxConnection.QueryByVectorValues(ctx, &amp;pinecone.QueryByVectorValuesRequest{
	       Vector:          queryVector,
	       TopK:            topK, // number of vectors to be returned
	       MetadataFilter:          metadataFilter,
	       SparseValues:    &amp;sparseValues,
	       IncludeValues:   true,
	       IncludeMetadata: true,
    })

    if err != nil {
	       log.Fatalf(&quot;Error encountered when querying by vector: %v&quot;, err)
    } else {
	       for _, match := range res.Matches {
		       fmt.Printf(&quot;Match vector `%s`, with score %f\n&quot;, match.Vector.Id, match.Score)
	       }
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.UpdateVector">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=26387:26479#L815">UpdateVector</a>
					<a class="permalink" href="#IndexConnection.UpdateVector">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) UpdateVector(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in *<a href="#UpdateVectorRequest">UpdateVectorRequest</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UpdateVector updates a vector in a Pinecone index by ID.
<p>Returns an error if the request fails, returns nil otherwise.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>in: An UpdateVectorRequest object with the parameters for the request.
</ul>
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    id := &quot;abc-1&quot;

    err = idxConnection.UpdateVector(ctx, &amp;pinecone.UpdateVectorRequest{
	       Id:     id,
	       Values: []float32{7.0, 8.0},
    })

    if err != nil {
	       log.Fatalf(&quot;Failed to update vector with ID %s. Error: %s&quot;, id, err)
    }
</pre>

				
				
				
			
				
				<h3 id="IndexConnection.UpsertVectors">func (*IndexConnection) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=4966:5058#L169">UpsertVectors</a>
					<a class="permalink" href="#IndexConnection.UpsertVectors">&#xb6;</a>
					
					
				</h3>
				<pre>func (idx *<a href="#IndexConnection">IndexConnection</a>) UpsertVectors(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, in []*<a href="#Vector">Vector</a>) (<a href="/pkg/builtin/#uint32">uint32</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>UpsertVectors upserts vectors into a Pinecone index.
<p>Parameters:
<ul>
<li>ctx: A context.Context object controls the request&apos;s lifetime,
allowing for the request to be canceled or to timeout according to the context&apos;s deadline.
<li>in: The vectors to upsert.
</ul>
<p>Returns the number of vectors upserted or an error if the request fails.
<p>Example:
<pre>    ctx := context.Background()

    clientParams := pinecone.NewClientParams{
	       ApiKey:    &quot;YOUR_API_KEY&quot;,
	       SourceTag: &quot;your_source_identifier&quot;, // optional
    }

    pc, err := pinecone.NewClient(clientParams)

    if err != nil {
	       log.Fatalf(&quot;Failed to create Client: %v&quot;, err)
    }

    idx, err := pc.DescribeIndex(ctx, &quot;your-index-name&quot;)

    if err != nil {
	       log.Fatalf(&quot;Failed to describe index \&quot;%s\&quot;. Error:%s&quot;, idx.Name, err)
    }

    idxConnection, err := pc.Index(pinecone.NewIndexConnParams{Host: idx.Host})

    if err != nil {
	       log.Fatalf(&quot;Failed to create IndexConnection for Host: %v. Error: %v&quot;, idx.Host, err)
    }

    metadataMap := map[string]interface{}{
	       &quot;genre&quot;: &quot;classical&quot;,
    }

    metadata, err := structpb.NewStruct(metadataMap)

    if err != nil {
	       log.Fatalf(&quot;Failed to create metadata map. Error: %v&quot;, err)
    }

    sparseValues := pinecone.SparseValues{
	       Indices: []uint32{0, 1},
	       Values:  []float32{1.0, 2.0},
    }

    vectors := []*pinecone.Vector{
	       {
		       Id:           &quot;abc-1&quot;,
		       Values:       []float32{1.0, 2.0},
		       Metadata:     metadata,
		       SparseValues: &amp;sparseValues,
	       },
    }

    count, err := idxConnection.UpsertVectors(ctx, vectors)

    if err != nil {
	       log.Fatalf(&quot;Failed to upsert vectors. Error: %v&quot;, err)
    } else {
	       log.Fatalf(&quot;Successfully upserted %d vector(s)!\n&quot;, count)
    }
</pre>

				
				
				
			
		
			
			
			<h2 id="IndexMetric">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=278:301#L1">IndexMetric</a>
				<a class="permalink" href="#IndexMetric">&#xb6;</a>
				
				
			</h2>
			<p>IndexMetric is the <a href="https://docs.pinecone.io/guides/indexes/understanding-indexes#distance-metrics">distance metric</a> to be used by similarity search against a Pinecone Index.

			<pre>type IndexMetric <a href="/pkg/builtin/#string">string</a></pre>

			
				
				<pre>const (
    <span id="Cosine">Cosine</span>     <a href="#IndexMetric">IndexMetric</a> = &#34;cosine&#34;     <span class="comment">// Default distance metric, ideal for textual data</span>
    <span id="Dotproduct">Dotproduct</span> <a href="#IndexMetric">IndexMetric</a> = &#34;dotproduct&#34; <span class="comment">// Ideal for hybrid search</span>
    <span id="Euclidean">Euclidean</span>  <a href="#IndexMetric">IndexMetric</a> = &#34;euclidean&#34;  <span class="comment">// Ideal for distance-based data (e.g. lat/long points)</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="IndexSpec">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=1623:1757#L38">IndexSpec</a>
				<a class="permalink" href="#IndexSpec">&#xb6;</a>
				
				
			</h2>
			<p>IndexSpec is the infrastructure specification (pods vs serverless) of a Pinecone Index.

			<pre>type IndexSpec struct {
<span id="IndexSpec.Pod"></span>    Pod        *<a href="#PodSpec">PodSpec</a>        `json:&#34;pod,omitempty&#34;`
<span id="IndexSpec.Serverless"></span>    Serverless *<a href="#ServerlessSpec">ServerlessSpec</a> `json:&#34;serverless,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="IndexStatus">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=1425:1530#L32">IndexStatus</a>
				<a class="permalink" href="#IndexStatus">&#xb6;</a>
				
				
			</h2>
			<p>IndexStatus is the status of a Pinecone Index.

			<pre>type IndexStatus struct {
<span id="IndexStatus.Ready"></span>    Ready <a href="/pkg/builtin/#bool">bool</a>             `json:&#34;ready&#34;`
<span id="IndexStatus.State"></span>    State <a href="#IndexStatusState">IndexStatusState</a> `json:&#34;state&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="IndexStatusState">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=619:647#L7">IndexStatusState</a>
				<a class="permalink" href="#IndexStatusState">&#xb6;</a>
				
				
			</h2>
			<p>IndexStatusState is the state of a Pinecone Index.

			<pre>type IndexStatusState <a href="/pkg/builtin/#string">string</a></pre>

			
				
				<pre>const (
    <span id="InitializationFailed">InitializationFailed</span> <a href="#IndexStatusState">IndexStatusState</a> = &#34;InitializationFailed&#34;
    <span id="Initializing">Initializing</span>         <a href="#IndexStatusState">IndexStatusState</a> = &#34;Initializing&#34;
    <span id="Ready">Ready</span>                <a href="#IndexStatusState">IndexStatusState</a> = &#34;Ready&#34;
    <span id="ScalingDown">ScalingDown</span>          <a href="#IndexStatusState">IndexStatusState</a> = &#34;ScalingDown&#34;
    <span id="ScalingDownPodSize">ScalingDownPodSize</span>   <a href="#IndexStatusState">IndexStatusState</a> = &#34;ScalingDownPodSize&#34;
    <span id="ScalingUp">ScalingUp</span>            <a href="#IndexStatusState">IndexStatusState</a> = &#34;ScalingUp&#34;
    <span id="ScalingUpPodSize">ScalingUpPodSize</span>     <a href="#IndexStatusState">IndexStatusState</a> = &#34;ScalingUpPodSize&#34;
    <span id="Terminating">Terminating</span>          <a href="#IndexStatusState">IndexStatusState</a> = &#34;Terminating&#34;
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="ListVectorsRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=8164:8273#L275">ListVectorsRequest</a>
				<a class="permalink" href="#ListVectorsRequest">&#xb6;</a>
				
				
			</h2>
			<p>ListVectorsRequest holds the parameters for the ListVectorsRequest object,
which is passed into the ListVectors method.
<p>Fields:
<ul>
<li>Prefix: The prefix by which to filter. If unspecified,
an empty string will be used which will list all vector ids in the namespace
<li>Limit: The maximum number of vectors to return. If unspecified, the server will use a default value.
<li>PaginationToken: The token for paginating through results.
</ul>

			<pre>type ListVectorsRequest struct {
<span id="ListVectorsRequest.Prefix"></span>    Prefix          *<a href="/pkg/builtin/#string">string</a>
<span id="ListVectorsRequest.Limit"></span>    Limit           *<a href="/pkg/builtin/#uint32">uint32</a>
<span id="ListVectorsRequest.PaginationToken"></span>    PaginationToken *<a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ListVectorsResponse">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=8598:8822#L288">ListVectorsResponse</a>
				<a class="permalink" href="#ListVectorsResponse">&#xb6;</a>
				
				
			</h2>
			<p>ListVectorsResponse holds the parameters for the ListVectorsResponse object,
which is returned by the ListVectors method.
<p>Fields:
<ul>
<li>VectorIds: The unique IDs of the returned vectors.
<li>Usage: The usage information for the request.
<li>NextPaginationToken: The token for paginating through results.
</ul>

			<pre>type ListVectorsResponse struct {
<span id="ListVectorsResponse.VectorIds"></span>    VectorIds           []*<a href="/pkg/builtin/#string">string</a> `json:&#34;vector_ids,omitempty&#34;`
<span id="ListVectorsResponse.Usage"></span>    Usage               *<a href="#Usage">Usage</a>    `json:&#34;usage,omitempty&#34;`
<span id="ListVectorsResponse.NextPaginationToken"></span>    NextPaginationToken *<a href="/pkg/builtin/#string">string</a>   `json:&#34;next_pagination_token,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Metadata">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=5956:5987#L145">Metadata</a>
				<a class="permalink" href="#Metadata">&#xb6;</a>
				
				
			</h2>
			<p>Metadata represents optional,
additional information that can be <a href="https://docs.pinecone.io/guides/data/filter-with-metadata#inserting-metadata-into-an-index">attached to, or updated for, a vector</a> in a Pinecone Index.

			<pre>type Metadata = <a href="/pkg/google.golang.org/protobuf/types/known/structpb/">structpb</a>.<a href="/pkg/google.golang.org/protobuf/types/known/structpb/#Struct">Struct</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="MetadataFilter">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=5647:5684#L139">MetadataFilter</a>
				<a class="permalink" href="#MetadataFilter">&#xb6;</a>
				
				
			</h2>
			<p>MetadataFilter represents the <a href="https://docs.pinecone.io/guides/data/filter-with-metadata#querying-an-index-with-metadata-filters">metadata filters</a> attached to a Pinecone request.
These optional metadata filters are applied to query and deletion requests.

			<pre>type MetadataFilter = <a href="/pkg/google.golang.org/protobuf/types/known/structpb/">structpb</a>.<a href="/pkg/google.golang.org/protobuf/types/known/structpb/#Struct">Struct</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NamespaceSummary">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=5042:5116#L124">NamespaceSummary</a>
				<a class="permalink" href="#NamespaceSummary">&#xb6;</a>
				
				
			</h2>
			<p>NamespaceSummary is a summary of stats for a Pinecone <a href="https://docs.pinecone.io/guides/indexes/use-namespaces">namespace</a>.

			<pre>type NamespaceSummary struct {
<span id="NamespaceSummary.VectorCount"></span>    VectorCount <a href="/pkg/builtin/#uint32">uint32</a> `json:&#34;vector_count&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NewClientBaseParams">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=4664:4792#L97">NewClientBaseParams</a>
				<a class="permalink" href="#NewClientBaseParams">&#xb6;</a>
				
				
			</h2>
			<p>NewClientBaseParams holds the parameters for creating a new Client instance while passing custom authentication
headers.
<p>Fields:
<ul>
<li>Headers: An optional map of additional HTTP headers to include in each API request to the control plane.
&quot;Authorization&quot; and &quot;X-Project-Id&quot; headers are required if authenticating using a JWT.
<li>Host: The host URL of the Pinecone control plane API. If not provided,
the default value is &quot;<a href="https://api.pinecone.io">https://api.pinecone.io</a>&quot;.
<li>RestClient: An optional *http.Client object to use for communication with the control plane API.
<li>SourceTag: An optional string used to help Pinecone attribute API activity.
</ul>
<p>See Client for code example.

			<pre>type NewClientBaseParams struct {
<span id="NewClientBaseParams.Headers"></span>    Headers    map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>
<span id="NewClientBaseParams.Host"></span>    Host       <a href="/pkg/builtin/#string">string</a>
<span id="NewClientBaseParams.RestClient"></span>    RestClient *<a href="/pkg/net/http/">http</a>.<a href="/pkg/net/http/#Client">Client</a>
<span id="NewClientBaseParams.SourceTag"></span>    SourceTag  <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NewClientParams">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=3644:3960#L77">NewClientParams</a>
				<a class="permalink" href="#NewClientParams">&#xb6;</a>
				
				
			</h2>
			<p>NewClientParams holds the parameters for creating a new Client instance while authenticating via an API key.
<p>Fields:
<ul>
<li>ApiKey: (Required) The API key used to authenticate with the Pinecone control plane API.
This value must be passed by the user unless it is set as an environment variable (&quot;PINECONE_API_KEY&quot;).
<li>Headers: An optional map of additional HTTP headers to include in each API request to the control plane.
<li>Host: The host URL of the Pinecone control plane API. If not provided,
the default value is &quot;<a href="https://api.pinecone.io">https://api.pinecone.io</a>&quot;.
<li>RestClient: An optional HTTP client to use for communication with the control plane API.
<li>SourceTag: An optional string used to help Pinecone attribute API activity.
</ul>
<p>See Client for code example.

			<pre>type NewClientParams struct {
<span id="NewClientParams.ApiKey"></span>    ApiKey     <a href="/pkg/builtin/#string">string</a>            <span class="comment">// required - provide through NewClientParams or environment variable PINECONE_API_KEY</span>
<span id="NewClientParams.Headers"></span>    Headers    map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// optional</span>
<span id="NewClientParams.Host"></span>    Host       <a href="/pkg/builtin/#string">string</a>            <span class="comment">// optional</span>
<span id="NewClientParams.RestClient"></span>    RestClient *<a href="/pkg/net/http/">http</a>.<a href="/pkg/net/http/#Client">Client</a>      <span class="comment">// optional</span>
<span id="NewClientParams.SourceTag"></span>    SourceTag  <a href="/pkg/builtin/#string">string</a>            <span class="comment">// optional</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NewIndexConnParams">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/client.go?s=5366:5657#L113">NewIndexConnParams</a>
				<a class="permalink" href="#NewIndexConnParams">&#xb6;</a>
				
				
			</h2>
			<p>NewIndexConnParams holds the parameters for creating an IndexConnection to a Pinecone index.
<p>Fields:
<ul>
<li>Host: The host URL of the Pinecone index. This is required. To find your host url use the DescribeIndex or ListIndexes methods.
Alternatively, the host is displayed in the Pinecone web console.
<li>Namespace: Optional index namespace to use for operations. If not provided, the default namespace of &quot;&quot; will be used.
<li>AdditionalMetdata: Optional additional metdata to be sent with each RPC request.
</ul>
<p>See Client.Index for code example.

			<pre>type NewIndexConnParams struct {
<span id="NewIndexConnParams.Host"></span>    Host               <a href="/pkg/builtin/#string">string</a>            <span class="comment">// required - obtained through DescribeIndex or ListIndexes</span>
<span id="NewIndexConnParams.Namespace"></span>    Namespace          <a href="/pkg/builtin/#string">string</a>            <span class="comment">// optional - if not provided the default namespace of &#34;&#34; will be used</span>
<span id="NewIndexConnParams.AdditionalMetadata"></span>    AdditionalMetadata map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// optional</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PineconeError">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/errors.go?s=32:83#L1">PineconeError</a>
				<a class="permalink" href="#PineconeError">&#xb6;</a>
				
				
			</h2>
			
			<pre>type PineconeError struct {
<span id="PineconeError.Code"></span>    Code <a href="/pkg/builtin/#int">int</a>
<span id="PineconeError.Msg"></span>    Msg  <a href="/pkg/builtin/#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PineconeError.Error">func (*PineconeError) <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/errors.go?s=85:124#L1">Error</a>
					<a class="permalink" href="#PineconeError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (pe *<a href="#PineconeError">PineconeError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PodSpec">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=3237:3716#L80">PodSpec</a>
				<a class="permalink" href="#PodSpec">&#xb6;</a>
				
				
			</h2>
			<p>PodSpec is the infrastructure specification of a pod-based Pinecone Index. Only available for pod-based Indexes.

			<pre>type PodSpec struct {
<span id="PodSpec.Environment"></span>    Environment      <a href="/pkg/builtin/#string">string</a>                 `json:&#34;environment&#34;`
<span id="PodSpec.PodType"></span>    PodType          <a href="/pkg/builtin/#string">string</a>                 `json:&#34;pod_type&#34;`
<span id="PodSpec.PodCount"></span>    PodCount         <a href="/pkg/builtin/#int32">int32</a>                  `json:&#34;pod_count&#34;`
<span id="PodSpec.Replicas"></span>    Replicas         <a href="/pkg/builtin/#int32">int32</a>                  `json:&#34;replicas&#34;`
<span id="PodSpec.ShardCount"></span>    ShardCount       <a href="/pkg/builtin/#int32">int32</a>                  `json:&#34;shard_count&#34;`
<span id="PodSpec.SourceCollection"></span>    SourceCollection *<a href="/pkg/builtin/#string">string</a>                `json:&#34;source_collection,omitempty&#34;`
<span id="PodSpec.MetadataConfig"></span>    MetadataConfig   *<a href="#PodSpecMetadataConfig">PodSpecMetadataConfig</a> `json:&#34;metadata_config,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PodSpecMetadataConfig">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=3036:3119#L75">PodSpecMetadataConfig</a>
				<a class="permalink" href="#PodSpecMetadataConfig">&#xb6;</a>
				
				
			</h2>
			<p>PodSpecMetadataConfig represents the metadata fields to be indexed when a Pinecone Index is created.

			<pre>type PodSpecMetadataConfig struct {
<span id="PodSpecMetadataConfig.Indexed"></span>    Indexed *[]<a href="/pkg/builtin/#string">string</a> `json:&#34;indexed,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="QueryByVectorIdRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=16102:16296#L501">QueryByVectorIdRequest</a>
				<a class="permalink" href="#QueryByVectorIdRequest">&#xb6;</a>
				
				
			</h2>
			<p>QueryByVectorIdRequest holds the parameters for the QueryByVectorIdRequest object,
which is passed into the QueryByVectorId method.
<p>Fields:
<ul>
<li>VectorId: The unique ID of the vector used to find similar vectors.
<li>TopK: The number of vectors to return.
<li>MetadataFilter: The filter to apply to your query.
<li>IncludeValues: Whether to include the values of the vectors in the response.
<li>IncludeMetadata: Whether to include the metadata associated with the vectors in the response.
<li>SparseValues: The sparse values of the query vector, if applicable.
</ul>

			<pre>type QueryByVectorIdRequest struct {
<span id="QueryByVectorIdRequest.VectorId"></span>    VectorId        <a href="/pkg/builtin/#string">string</a>
<span id="QueryByVectorIdRequest.TopK"></span>    TopK            <a href="/pkg/builtin/#uint32">uint32</a>
<span id="QueryByVectorIdRequest.Filter"></span>    Filter          *<a href="#MetadataFilter">MetadataFilter</a>
<span id="QueryByVectorIdRequest.IncludeValues"></span>    IncludeValues   <a href="/pkg/builtin/#bool">bool</a>
<span id="QueryByVectorIdRequest.IncludeMetadata"></span>    IncludeMetadata <a href="/pkg/builtin/#bool">bool</a>
<span id="QueryByVectorIdRequest.SparseValues"></span>    SparseValues    *<a href="#SparseValues">SparseValues</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="QueryByVectorValuesRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=11961:12162#L384">QueryByVectorValuesRequest</a>
				<a class="permalink" href="#QueryByVectorValuesRequest">&#xb6;</a>
				
				
			</h2>
			<p>QueryByVectorValuesRequest holds the parameters for the QueryByVectorValuesRequest object,
which is passed into the QueryByVectorValues method.
<p>Fields:
<ul>
<li>Vector: The query vector used to find similar vectors.
<li>TopK: The number of vectors to return.
<li>MetadataFilter: The filter to apply to your query.
<li>IncludeValues: Whether to include the values of the vectors in the response.
<li>IncludeMetadata: Whether to include the metadata associated with the vectors in the response.
<li>SparseValues: The sparse values of the query vector, if applicable.
</ul>

			<pre>type QueryByVectorValuesRequest struct {
<span id="QueryByVectorValuesRequest.Vector"></span>    Vector          []<a href="/pkg/builtin/#float32">float32</a>
<span id="QueryByVectorValuesRequest.TopK"></span>    TopK            <a href="/pkg/builtin/#uint32">uint32</a>
<span id="QueryByVectorValuesRequest.Filter"></span>    Filter          *<a href="#MetadataFilter">MetadataFilter</a>
<span id="QueryByVectorValuesRequest.IncludeValues"></span>    IncludeValues   <a href="/pkg/builtin/#bool">bool</a>
<span id="QueryByVectorValuesRequest.IncludeMetadata"></span>    IncludeMetadata <a href="/pkg/builtin/#bool">bool</a>
<span id="QueryByVectorValuesRequest.SparseValues"></span>    SparseValues    *<a href="#SparseValues">SparseValues</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="QueryVectorsResponse">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=12440:12578#L399">QueryVectorsResponse</a>
				<a class="permalink" href="#QueryVectorsResponse">&#xb6;</a>
				
				
			</h2>
			<p>QueryVectorsResponse holds the parameters for the QueryVectorsResponse object,
which is returned by the QueryByVectorValues method.
<p>Fields:
<ul>
<li>Matches: The vectors that are most similar to the query vector.
<li>Usage: The usage information for the request.
</ul>

			<pre>type QueryVectorsResponse struct {
<span id="QueryVectorsResponse.Matches"></span>    Matches []*<a href="#ScoredVector">ScoredVector</a> `json:&#34;matches,omitempty&#34;`
<span id="QueryVectorsResponse.Usage"></span>    Usage   *<a href="#Usage">Usage</a>          `json:&#34;usage,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ScoredVector">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=4476:4577#L108">ScoredVector</a>
				<a class="permalink" href="#ScoredVector">&#xb6;</a>
				
				
			</h2>
			<p>ScoredVector is a vector with an associated similarity score calculated according to the distance metric of the
Index.

			<pre>type ScoredVector struct {
<span id="ScoredVector.Vector"></span>    Vector *<a href="#Vector">Vector</a> `json:&#34;vector,omitempty&#34;`
<span id="ScoredVector.Score"></span>    Score  <a href="/pkg/builtin/#float32">float32</a> `json:&#34;score&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ServerlessSpec">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=3843:3934#L91">ServerlessSpec</a>
				<a class="permalink" href="#ServerlessSpec">&#xb6;</a>
				
				
			</h2>
			<p>ServerlessSpec is the infrastructure specification of a serverless Pinecone Index. Only available for serverless Indexes.

			<pre>type ServerlessSpec struct {
<span id="ServerlessSpec.Cloud"></span>    Cloud  <a href="#Cloud">Cloud</a>  `json:&#34;cloud&#34;`
<span id="ServerlessSpec.Region"></span>    Region <a href="/pkg/builtin/#string">string</a> `json:&#34;region&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="SparseValues">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=4777:4896#L116">SparseValues</a>
				<a class="permalink" href="#SparseValues">&#xb6;</a>
				
				
			</h2>
			<p>SparseValues is a sparse vector objects, most commonly used for <a href="https://docs.pinecone.io/guides/data/understanding-hybrid-search#hybrid-search-in-pinecone">hybrid search</a>.

			<pre>type SparseValues struct {
<span id="SparseValues.Indices"></span>    Indices []<a href="/pkg/builtin/#uint32">uint32</a>  `json:&#34;indices,omitempty&#34;`
<span id="SparseValues.Values"></span>    Values  []<a href="/pkg/builtin/#float32">float32</a> `json:&#34;values,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="UpdateVectorRequest">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/index_connection.go?s=24813:24945#L762">UpdateVectorRequest</a>
				<a class="permalink" href="#UpdateVectorRequest">&#xb6;</a>
				
				
			</h2>
			<p>UpdateVectorRequest holds the parameters for the UpdateVectorRequest object,
which is passed into the UpdateVector method.
<p>Fields:
<ul>
<li>Id: The unique ID of the vector to update.
<li>Values: The values with which you want to update the vector.
<li>SparseValues: The sparse values with which you want to update the vector.
<li>Metadata: The metadata with which you want to update the vector.
</ul>

			<pre>type UpdateVectorRequest struct {
<span id="UpdateVectorRequest.Id"></span>    Id           <a href="/pkg/builtin/#string">string</a>
<span id="UpdateVectorRequest.Values"></span>    Values       []<a href="/pkg/builtin/#float32">float32</a>
<span id="UpdateVectorRequest.SparseValues"></span>    SparseValues *<a href="#SparseValues">SparseValues</a>
<span id="UpdateVectorRequest.Metadata"></span>    Metadata     *<a href="#Metadata">Metadata</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Usage">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=5299:5358#L131">Usage</a>
				<a class="permalink" href="#Usage">&#xb6;</a>
				
				
			</h2>
			<p>Usage is the usage stats (<a href="https://docs.pinecone.io/guides/organizations/manage-cost/understanding-cost#serverless-indexes">Read Units</a>) for a Pinecone Index.

			<pre>type Usage struct {
<span id="Usage.ReadUnits"></span>    ReadUnits <a href="/pkg/builtin/#uint32">uint32</a> `json:&#34;read_units&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Vector">type <a href="/src/github.com/pinecone-io/go-pinecone/pinecone/models.go?s=4116:4349#L99">Vector</a>
				<a class="permalink" href="#Vector">&#xb6;</a>
				
				
			</h2>
			<p>Vector is a <a href="https://docs.pinecone.io/guides/get-started/key-concepts#dense-vector">dense or sparse vector object</a> with optional metadata.

			<pre>type Vector struct {
<span id="Vector.Id"></span>    Id           <a href="/pkg/builtin/#string">string</a>        `json:&#34;id&#34;`
<span id="Vector.Values"></span>    Values       []<a href="/pkg/builtin/#float32">float32</a>     `json:&#34;values,omitempty&#34;`
<span id="Vector.SparseValues"></span>    SparseValues *<a href="#SparseValues">SparseValues</a> `json:&#34;sparse_values,omitempty&#34;`
<span id="Vector.Metadata"></span>    Metadata     *<a href="#Metadata">Metadata</a>     `json:&#34;metadata,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.22.4.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
