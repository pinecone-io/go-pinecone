// Package db_control provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package db_control

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for BackupModelMetric.
const (
	BackupModelMetricCosine     BackupModelMetric = "cosine"
	BackupModelMetricDotproduct BackupModelMetric = "dotproduct"
	BackupModelMetricEuclidean  BackupModelMetric = "euclidean"
)

// Defines values for CollectionModelStatus.
const (
	CollectionModelStatusInitializing CollectionModelStatus = "Initializing"
	CollectionModelStatusReady        CollectionModelStatus = "Ready"
	CollectionModelStatusTerminating  CollectionModelStatus = "Terminating"
)

// Defines values for CreateIndexForModelRequestCloud.
const (
	CreateIndexForModelRequestCloudAws   CreateIndexForModelRequestCloud = "aws"
	CreateIndexForModelRequestCloudAzure CreateIndexForModelRequestCloud = "azure"
	CreateIndexForModelRequestCloudGcp   CreateIndexForModelRequestCloud = "gcp"
)

// Defines values for CreateIndexForModelRequestEmbedMetric.
const (
	CreateIndexForModelRequestEmbedMetricCosine     CreateIndexForModelRequestEmbedMetric = "cosine"
	CreateIndexForModelRequestEmbedMetricDotproduct CreateIndexForModelRequestEmbedMetric = "dotproduct"
	CreateIndexForModelRequestEmbedMetricEuclidean  CreateIndexForModelRequestEmbedMetric = "euclidean"
)

// Defines values for CreateIndexRequestMetric.
const (
	CreateIndexRequestMetricCosine     CreateIndexRequestMetric = "cosine"
	CreateIndexRequestMetricDotproduct CreateIndexRequestMetric = "dotproduct"
	CreateIndexRequestMetricEuclidean  CreateIndexRequestMetric = "euclidean"
)

// Defines values for DeletionProtection.
const (
	Disabled DeletionProtection = "disabled"
	Enabled  DeletionProtection = "enabled"
)

// Defines values for ErrorResponseErrorCode.
const (
	ABORTED             ErrorResponseErrorCode = "ABORTED"
	ALREADYEXISTS       ErrorResponseErrorCode = "ALREADY_EXISTS"
	DATALOSS            ErrorResponseErrorCode = "DATA_LOSS"
	DEADLINEEXCEEDED    ErrorResponseErrorCode = "DEADLINE_EXCEEDED"
	FAILEDPRECONDITION  ErrorResponseErrorCode = "FAILED_PRECONDITION"
	FORBIDDEN           ErrorResponseErrorCode = "FORBIDDEN"
	INTERNAL            ErrorResponseErrorCode = "INTERNAL"
	INVALIDARGUMENT     ErrorResponseErrorCode = "INVALID_ARGUMENT"
	NOTFOUND            ErrorResponseErrorCode = "NOT_FOUND"
	OK                  ErrorResponseErrorCode = "OK"
	OUTOFRANGE          ErrorResponseErrorCode = "OUT_OF_RANGE"
	PAYMENTREQUIRED     ErrorResponseErrorCode = "PAYMENT_REQUIRED"
	PERMISSIONDENIED    ErrorResponseErrorCode = "PERMISSION_DENIED"
	QUOTAEXCEEDED       ErrorResponseErrorCode = "QUOTA_EXCEEDED"
	RESOURCEEXHAUSTED   ErrorResponseErrorCode = "RESOURCE_EXHAUSTED"
	UNAUTHENTICATED     ErrorResponseErrorCode = "UNAUTHENTICATED"
	UNAVAILABLE         ErrorResponseErrorCode = "UNAVAILABLE"
	UNIMPLEMENTED       ErrorResponseErrorCode = "UNIMPLEMENTED"
	UNKNOWN             ErrorResponseErrorCode = "UNKNOWN"
	UNPROCESSABLEENTITY ErrorResponseErrorCode = "UNPROCESSABLE_ENTITY"
)

// Defines values for IndexModelMetric.
const (
	IndexModelMetricCosine     IndexModelMetric = "cosine"
	IndexModelMetricDotproduct IndexModelMetric = "dotproduct"
	IndexModelMetricEuclidean  IndexModelMetric = "euclidean"
)

// Defines values for IndexModelStatusState.
const (
	IndexModelStatusStateDisabled             IndexModelStatusState = "Disabled"
	IndexModelStatusStateInitializationFailed IndexModelStatusState = "InitializationFailed"
	IndexModelStatusStateInitializing         IndexModelStatusState = "Initializing"
	IndexModelStatusStateReady                IndexModelStatusState = "Ready"
	IndexModelStatusStateScalingDown          IndexModelStatusState = "ScalingDown"
	IndexModelStatusStateScalingDownPodSize   IndexModelStatusState = "ScalingDownPodSize"
	IndexModelStatusStateScalingUp            IndexModelStatusState = "ScalingUp"
	IndexModelStatusStateScalingUpPodSize     IndexModelStatusState = "ScalingUpPodSize"
	IndexModelStatusStateTerminating          IndexModelStatusState = "Terminating"
)

// Defines values for ModelIndexEmbedMetric.
const (
	Cosine     ModelIndexEmbedMetric = "cosine"
	Dotproduct ModelIndexEmbedMetric = "dotproduct"
	Euclidean  ModelIndexEmbedMetric = "euclidean"
)

// Defines values for ServerlessSpecCloud.
const (
	ServerlessSpecCloudAws   ServerlessSpecCloud = "aws"
	ServerlessSpecCloudAzure ServerlessSpecCloud = "azure"
	ServerlessSpecCloudGcp   ServerlessSpecCloud = "gcp"
)

// BackupList The list of backups that exist in the project.
type BackupList struct {
	Data *[]BackupModel `json:"data,omitempty"`

	// Pagination The pagination object that is returned with paginated responses.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// BackupModel The BackupModel describes the configuration and status of a Pinecone backup.
type BackupModel struct {
	// BackupId Unique identifier for the backup.
	BackupId string `json:"backup_id"`

	// Cloud Cloud provider where the backup is stored.
	Cloud string `json:"cloud"`

	// CreatedAt Timestamp when the backup was created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Optional description providing context for the backup.
	Description *string `json:"description,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	Metric *BackupModelMetric `json:"metric,omitempty"`

	// Name Optional user-defined name for the backup.
	Name *string `json:"name,omitempty"`

	// NamespaceCount Number of namespaces in the backup.
	NamespaceCount *int `json:"namespace_count,omitempty"`

	// RecordCount Total number of records in the backup.
	RecordCount *int `json:"record_count,omitempty"`

	// Region Cloud region where the backup is stored.
	Region string `json:"region"`

	// SizeBytes Size of the backup in bytes.
	SizeBytes *int `json:"size_bytes,omitempty"`

	// SourceIndexId ID of the index.
	SourceIndexId string `json:"source_index_id"`

	// SourceIndexName Name of the index from which the backup was taken.
	SourceIndexName string `json:"source_index_name"`

	// Status Current status of the backup (e.g., Initializing, Ready, Failed).
	Status string `json:"status"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// BackupModelMetric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
type BackupModelMetric string

// ByocSpec Configuration needed to deploy an index in a BYOC environment.
type ByocSpec struct {
	// Environment The environment where the index is hosted.
	Environment string `json:"environment"`
}

// CollectionList The list of collections that exist in the project.
type CollectionList struct {
	Collections *[]CollectionModel `json:"collections,omitempty"`
}

// CollectionModel The CollectionModel describes the configuration and status of a Pinecone collection.
type CollectionModel struct {
	// Dimension The dimension of the vectors stored in each record held in the collection.
	Dimension *int32 `json:"dimension,omitempty"`

	// Environment The environment where the collection is hosted.
	Environment string `json:"environment"`

	// Name The name of the collection.
	Name string `json:"name"`

	// Size The size of the collection in bytes.
	Size *int64 `json:"size,omitempty"`

	// Status The status of the collection.
	Status CollectionModelStatus `json:"status"`

	// VectorCount The number of records stored in the collection.
	VectorCount *int32 `json:"vector_count,omitempty"`
}

// CollectionModelStatus The status of the collection.
type CollectionModelStatus string

// ConfigureIndexRequest Configuration used to scale an index.
type ConfigureIndexRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Embed Configure the integrated inference embedding settings for this index.
	//
	// You can convert an existing index to an integrated index by specifying the embedding model and field_map. The index vector type and dimension must match the model vector type and dimension, and the index similarity metric must be supported by the model. Refer to the [model guide](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) for available models and model details.
	//
	// You can later change the embedding configuration to update the field map, read parameters, or write parameters. Once set, the model cannot be changed.
	Embed *struct {
		// FieldMap Identifies the name of the text field from your document model that will be embedded.
		FieldMap *map[string]interface{} `json:"field_map,omitempty"`

		// Model The name of the embedding model to use with the index. The index dimension and model dimension must match, and the index similarity metric must be supported by the model. The index embedding model cannot be changed once set.
		Model *string `json:"model,omitempty"`

		// ReadParameters The read parameters for the embedding model.
		ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

		// WriteParameters The write parameters for the embedding model.
		WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
	} `json:"embed,omitempty"`
	Spec *struct {
		Pod struct {
			// PodType The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
			PodType *string `json:"pod_type,omitempty"`

			// Replicas The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
			Replicas *int32 `json:"replicas,omitempty"`
		} `json:"pod"`
	} `json:"spec,omitempty"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// CreateBackupRequest The configuration needed to create a backup of an index.
type CreateBackupRequest struct {
	// Description A description of the backup.
	Description *string `json:"description,omitempty"`

	// Name The name of the backup.
	Name *string `json:"name,omitempty"`
}

// CreateCollectionRequest The configuration needed to create a Pinecone collection.
type CreateCollectionRequest struct {
	// Name The name of the collection to be created. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Source The name of the index to be used as the source for the collection.
	Source string `json:"source"`
}

// CreateIndexForModelRequest The desired configuration for the index and associated embedding model.
type CreateIndexForModelRequest struct {
	// Cloud The public cloud where you would like your index hosted.
	Cloud CreateIndexForModelRequestCloud `json:"cloud"`

	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Embed Specify the integrated inference embedding configuration for the index.
	//
	// Once set the model cannot be changed, but you can later update the embedding configuration for an integrated inference index including field map, read parameters, or write parameters.
	//
	// Refer to the [model guide](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) for available models and model details.
	Embed struct {
		// Dimension The dimension of embedding vectors produced for the index.
		Dimension *int `json:"dimension,omitempty"`

		// FieldMap Identifies the name of the text field from your document model that will be embedded.
		FieldMap map[string]interface{} `json:"field_map"`

		// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
		Metric *CreateIndexForModelRequestEmbedMetric `json:"metric,omitempty"`

		// Model The name of the embedding model to use for the index.
		Model string `json:"model"`

		// ReadParameters The read parameters for the embedding model.
		ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

		// WriteParameters The write parameters for the embedding model.
		WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
	} `json:"embed"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Region The region where you would like your index to be created.
	Region string `json:"region"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// CreateIndexForModelRequestCloud The public cloud where you would like your index hosted.
type CreateIndexForModelRequestCloud string

// CreateIndexForModelRequestEmbedMetric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
type CreateIndexForModelRequestEmbedMetric string

// CreateIndexFromBackupRequest The configuration needed to create a Pinecone index from a backup.
type CreateIndexFromBackupRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// CreateIndexFromBackupResponse The response for creating an index from a backup.
type CreateIndexFromBackupResponse struct {
	// IndexId The ID of the index that was created from the backup.
	IndexId string `json:"index_id"`

	// RestoreJobId The ID of the restore job that was created.
	RestoreJobId string `json:"restore_job_id"`
}

// CreateIndexRequest The configuration needed to create a Pinecone index.
type CreateIndexRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	Metric *CreateIndexRequestMetric `json:"metric,omitempty"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Spec The spec object defines how the index should be deployed.
	//
	// For serverless indexes, you set only the [cloud and region](http://docs.pinecone.io/guides/index-data/create-an-index#cloud-regions) where the index should be hosted. For pod-based indexes, you set the [environment](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-environments) where the index should be hosted, the [pod type and size](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-types) to use, and other index characteristics. For [BYOC indexes](http://docs.pinecone.io/guides/production/bring-your-own-cloud), you set the environment name provided to you during onboarding.
	Spec IndexSpec `json:"spec"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType *string `json:"vector_type,omitempty"`
}

// CreateIndexRequestMetric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
type CreateIndexRequestMetric string

// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
type DeletionProtection string

// ErrorResponse The response shape used for all error responses.
type ErrorResponse struct {
	// Error Detailed information about the error that occurred.
	Error struct {
		Code ErrorResponseErrorCode `json:"code"`

		// Details Additional information about the error. This field is not guaranteed to be present.
		Details *map[string]interface{} `json:"details,omitempty"`
		Message string                  `json:"message"`
	} `json:"error"`

	// Status The HTTP status code of the error.
	Status int `json:"status"`
}

// ErrorResponseErrorCode defines model for ErrorResponse.Error.Code.
type ErrorResponseErrorCode string

// IndexList The list of indexes that exist in the project.
type IndexList struct {
	Indexes *[]IndexModel `json:"indexes,omitempty"`
}

// IndexModel The IndexModel describes the configuration and status of a Pinecone index.
type IndexModel struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Embed The embedding model and document fields mapped to embedding inputs.
	Embed *ModelIndexEmbed `json:"embed,omitempty"`

	// Host The URL address where the index is hosted.
	Host string `json:"host"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	Metric IndexModelMetric `json:"metric"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// PrivateHost The private endpoint URL of an index.
	PrivateHost *string `json:"private_host,omitempty"`
	Spec        struct {
		// Byoc Configuration needed to deploy an index in a BYOC environment.
		Byoc *ByocSpec `json:"byoc,omitempty"`

		// Pod Configuration needed to deploy a pod-based index.
		Pod *PodSpec `json:"pod,omitempty"`

		// Serverless Configuration needed to deploy a serverless index.
		Serverless *ServerlessSpec `json:"serverless,omitempty"`
	} `json:"spec"`
	Status struct {
		Ready bool                  `json:"ready"`
		State IndexModelStatusState `json:"state"`
	} `json:"status"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType string `json:"vector_type"`
}

// IndexModelMetric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
type IndexModelMetric string

// IndexModelStatusState defines model for IndexModel.Status.State.
type IndexModelStatusState string

// IndexSpec The spec object defines how the index should be deployed.
//
// For serverless indexes, you set only the [cloud and region](http://docs.pinecone.io/guides/index-data/create-an-index#cloud-regions) where the index should be hosted. For pod-based indexes, you set the [environment](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-environments) where the index should be hosted, the [pod type and size](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-types) to use, and other index characteristics. For [BYOC indexes](http://docs.pinecone.io/guides/production/bring-your-own-cloud), you set the environment name provided to you during onboarding.
type IndexSpec struct {
	// Byoc Configuration needed to deploy an index in a BYOC environment.
	Byoc *ByocSpec `json:"byoc,omitempty"`

	// Pod Configuration needed to deploy a pod-based index.
	Pod *PodSpec `json:"pod,omitempty"`

	// Serverless Configuration needed to deploy a serverless index.
	Serverless *ServerlessSpec `json:"serverless,omitempty"`
	union      json.RawMessage
}

// IndexSpec0 defines model for .
type IndexSpec0 = interface{}

// IndexSpec1 defines model for .
type IndexSpec1 = interface{}

// IndexSpec2 defines model for .
type IndexSpec2 = interface{}

// IndexTags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
type IndexTags map[string]string

// ModelIndexEmbed The embedding model and document fields mapped to embedding inputs.
type ModelIndexEmbed struct {
	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// FieldMap Identifies the name of the text field from your document model that is embedded.
	FieldMap *map[string]interface{} `json:"field_map,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
	Metric *ModelIndexEmbedMetric `json:"metric,omitempty"`

	// Model The name of the embedding model used to create the index.
	Model string `json:"model"`

	// ReadParameters The read parameters for the embedding model.
	ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType *string `json:"vector_type,omitempty"`

	// WriteParameters The write parameters for the embedding model.
	WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
}

// ModelIndexEmbedMetric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
type ModelIndexEmbedMetric string

// PaginationResponse The pagination object that is returned with paginated responses.
type PaginationResponse struct {
	// Next The token to use to retrieve the next page of results.
	Next string `json:"next"`
}

// PodSpec Configuration needed to deploy a pod-based index.
type PodSpec struct {
	// Environment The environment where the index is hosted.
	Environment string `json:"environment"`

	// MetadataConfig Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `metadata_config` is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
	MetadataConfig *struct {
		// Indexed By default, all metadata is indexed; to change this behavior, use this property to specify an array of metadata fields that should be indexed.
		Indexed *[]string `json:"indexed,omitempty"`
	} `json:"metadata_config,omitempty"`

	// PodType The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
	PodType string `json:"pod_type"`

	// Pods The number of pods to be used in the index. This should be equal to `shards` x `replicas`.'
	Pods *int `json:"pods,omitempty"`

	// Replicas The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
	Replicas *int32 `json:"replicas,omitempty"`

	// Shards The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
	Shards *int32 `json:"shards,omitempty"`

	// SourceCollection The name of the collection to be used as the source for the index.
	SourceCollection *string `json:"source_collection,omitempty"`
}

// RestoreJobList The list of restore jobs that exist in the project.
type RestoreJobList struct {
	Data []RestoreJobModel `json:"data"`

	// Pagination The pagination object that is returned with paginated responses.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// RestoreJobModel The RestoreJobModel describes the status of a restore job.
type RestoreJobModel struct {
	// BackupId Backup used for the restore
	BackupId string `json:"backup_id"`

	// CompletedAt Timestamp when the restore job finished
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Timestamp when the restore job started
	CreatedAt time.Time `json:"created_at"`

	// PercentComplete The progress made by the restore job out of 100
	PercentComplete *float32 `json:"percent_complete,omitempty"`

	// RestoreJobId Unique identifier for the restore job
	RestoreJobId string `json:"restore_job_id"`

	// Status Status of the restore job
	Status string `json:"status"`

	// TargetIndexId ID of the index
	TargetIndexId string `json:"target_index_id"`

	// TargetIndexName Name of the index into which data is being restored
	TargetIndexName string `json:"target_index_name"`
}

// ServerlessSpec Configuration needed to deploy a serverless index.
type ServerlessSpec struct {
	// Cloud The public cloud where you would like your index hosted.
	Cloud ServerlessSpecCloud `json:"cloud"`

	// Region The region where you would like your index to be created.
	Region string `json:"region"`

	// SourceCollection The name of the collection to be used as the source for the index.
	SourceCollection *string `json:"source_collection,omitempty"`
}

// ServerlessSpecCloud The public cloud where you would like your index hosted.
type ServerlessSpecCloud string

// ListProjectBackupsParams defines parameters for ListProjectBackups.
type ListProjectBackupsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListIndexBackupsParams defines parameters for ListIndexBackups.
type ListIndexBackupsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// ListRestoreJobsParams defines parameters for ListRestoreJobs.
type ListRestoreJobsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// CreateIndexFromBackupOperationJSONRequestBody defines body for CreateIndexFromBackupOperation for application/json ContentType.
type CreateIndexFromBackupOperationJSONRequestBody = CreateIndexFromBackupRequest

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollectionRequest

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = CreateIndexRequest

// CreateIndexForModelJSONRequestBody defines body for CreateIndexForModel for application/json ContentType.
type CreateIndexForModelJSONRequestBody = CreateIndexForModelRequest

// ConfigureIndexJSONRequestBody defines body for ConfigureIndex for application/json ContentType.
type ConfigureIndexJSONRequestBody = ConfigureIndexRequest

// CreateBackupJSONRequestBody defines body for CreateBackup for application/json ContentType.
type CreateBackupJSONRequestBody = CreateBackupRequest

// AsIndexSpec0 returns the union data inside the IndexSpec as a IndexSpec0
func (t IndexSpec) AsIndexSpec0() (IndexSpec0, error) {
	var body IndexSpec0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec0 overwrites any union data inside the IndexSpec as the provided IndexSpec0
func (t *IndexSpec) FromIndexSpec0(v IndexSpec0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec0 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec0
func (t *IndexSpec) MergeIndexSpec0(v IndexSpec0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexSpec1 returns the union data inside the IndexSpec as a IndexSpec1
func (t IndexSpec) AsIndexSpec1() (IndexSpec1, error) {
	var body IndexSpec1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec1 overwrites any union data inside the IndexSpec as the provided IndexSpec1
func (t *IndexSpec) FromIndexSpec1(v IndexSpec1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec1 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec1
func (t *IndexSpec) MergeIndexSpec1(v IndexSpec1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexSpec2 returns the union data inside the IndexSpec as a IndexSpec2
func (t IndexSpec) AsIndexSpec2() (IndexSpec2, error) {
	var body IndexSpec2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec2 overwrites any union data inside the IndexSpec as the provided IndexSpec2
func (t *IndexSpec) FromIndexSpec2(v IndexSpec2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec2 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec2
func (t *IndexSpec) MergeIndexSpec2(v IndexSpec2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndexSpec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Byoc != nil {
		object["byoc"], err = json.Marshal(t.Byoc)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'byoc': %w", err)
		}
	}

	if t.Pod != nil {
		object["pod"], err = json.Marshal(t.Pod)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pod': %w", err)
		}
	}

	if t.Serverless != nil {
		object["serverless"], err = json.Marshal(t.Serverless)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'serverless': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *IndexSpec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["byoc"]; found {
		err = json.Unmarshal(raw, &t.Byoc)
		if err != nil {
			return fmt.Errorf("error reading 'byoc': %w", err)
		}
	}

	if raw, found := object["pod"]; found {
		err = json.Unmarshal(raw, &t.Pod)
		if err != nil {
			return fmt.Errorf("error reading 'pod': %w", err)
		}
	}

	if raw, found := object["serverless"]; found {
		err = json.Unmarshal(raw, &t.Serverless)
		if err != nil {
			return fmt.Errorf("error reading 'serverless': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListProjectBackups request
	ListProjectBackups(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackup request
	DeleteBackup(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeBackup request
	DescribeBackup(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexFromBackupOperationWithBody request with any body
	CreateIndexFromBackupOperationWithBody(ctx context.Context, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndexFromBackupOperation(ctx context.Context, backupId string, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollections request
	ListCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollectionWithBody request with any body
	CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollection request
	DeleteCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeCollection request
	DescribeCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexes request
	ListIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexWithBody request with any body
	CreateIndexWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexForModelWithBody request with any body
	CreateIndexForModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndexForModel(ctx context.Context, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request
	DeleteIndex(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeIndex request
	DescribeIndex(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureIndexWithBody request with any body
	ConfigureIndexWithBody(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureIndex(ctx context.Context, indexName string, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexBackups request
	ListIndexBackups(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackupWithBody request with any body
	CreateBackupWithBody(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackup(ctx context.Context, indexName string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRestoreJobs request
	ListRestoreJobs(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeRestoreJob request
	DescribeRestoreJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListProjectBackups(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBackupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackup(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupRequest(c.Server, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeBackup(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeBackupRequest(c.Server, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexFromBackupOperationWithBody(ctx context.Context, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexFromBackupOperationRequestWithBody(c.Server, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexFromBackupOperation(ctx context.Context, backupId string, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexFromBackupOperationRequest(c.Server, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollections(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeCollection(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeCollectionRequest(c.Server, collectionName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexForModelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexForModelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexForModel(ctx context.Context, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexForModelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, indexName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeIndex(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeIndexRequest(c.Server, indexName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureIndexWithBody(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureIndexRequestWithBody(c.Server, indexName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureIndex(ctx context.Context, indexName string, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureIndexRequest(c.Server, indexName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexBackups(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexBackupsRequest(c.Server, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupWithBody(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequestWithBody(c.Server, indexName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackup(ctx context.Context, indexName string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequest(c.Server, indexName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRestoreJobs(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRestoreJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeRestoreJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeRestoreJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListProjectBackupsRequest generates requests for ListProjectBackups
func NewListProjectBackupsRequest(server string, params *ListProjectBackupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBackupRequest generates requests for DeleteBackup
func NewDeleteBackupRequest(server string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeBackupRequest generates requests for DescribeBackup
func NewDescribeBackupRequest(server string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIndexFromBackupOperationRequest calls the generic CreateIndexFromBackupOperation builder with application/json body
func NewCreateIndexFromBackupOperationRequest(server string, backupId string, body CreateIndexFromBackupOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexFromBackupOperationRequestWithBody(server, backupId, "application/json", bodyReader)
}

// NewCreateIndexFromBackupOperationRequestWithBody generates requests for CreateIndexFromBackupOperation with any type of body
func NewCreateIndexFromBackupOperationRequestWithBody(server string, backupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s/create-index", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCollectionsRequest generates requests for ListCollections
func NewListCollectionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionRequest generates requests for DeleteCollection
func NewDeleteCollectionRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeCollectionRequest generates requests for DescribeCollection
func NewDescribeCollectionRequest(server string, collectionName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIndexesRequest generates requests for ListIndexes
func NewListIndexesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIndexForModelRequest calls the generic CreateIndexForModel builder with application/json body
func NewCreateIndexForModelRequest(server string, body CreateIndexForModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexForModelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIndexForModelRequestWithBody generates requests for CreateIndexForModel with any type of body
func NewCreateIndexForModelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/create-for-model")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIndexRequest generates requests for DeleteIndex
func NewDeleteIndexRequest(server string, indexName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeIndexRequest generates requests for DescribeIndex
func NewDescribeIndexRequest(server string, indexName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigureIndexRequest calls the generic ConfigureIndex builder with application/json body
func NewConfigureIndexRequest(server string, indexName string, body ConfigureIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureIndexRequestWithBody(server, indexName, "application/json", bodyReader)
}

// NewConfigureIndexRequestWithBody generates requests for ConfigureIndex with any type of body
func NewConfigureIndexRequestWithBody(server string, indexName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListIndexBackupsRequest generates requests for ListIndexBackups
func NewListIndexBackupsRequest(server string, indexName string, params *ListIndexBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackupRequest calls the generic CreateBackup builder with application/json body
func NewCreateBackupRequest(server string, indexName string, body CreateBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackupRequestWithBody(server, indexName, "application/json", bodyReader)
}

// NewCreateBackupRequestWithBody generates requests for CreateBackup with any type of body
func NewCreateBackupRequestWithBody(server string, indexName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRestoreJobsRequest generates requests for ListRestoreJobs
func NewListRestoreJobsRequest(server string, params *ListRestoreJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeRestoreJobRequest generates requests for DescribeRestoreJob
func NewDescribeRestoreJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListProjectBackupsWithResponse request
	ListProjectBackupsWithResponse(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectBackupsResponse, error)

	// DeleteBackupWithResponse request
	DeleteBackupWithResponse(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error)

	// DescribeBackupWithResponse request
	DescribeBackupWithResponse(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*DescribeBackupResponse, error)

	// CreateIndexFromBackupOperationWithBodyWithResponse request with any body
	CreateIndexFromBackupOperationWithBodyWithResponse(ctx context.Context, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error)

	CreateIndexFromBackupOperationWithResponse(ctx context.Context, backupId string, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error)

	// ListCollectionsWithResponse request
	ListCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error)

	// CreateCollectionWithBodyWithResponse request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// DeleteCollectionWithResponse request
	DeleteCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error)

	// DescribeCollectionWithResponse request
	DescribeCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*DescribeCollectionResponse, error)

	// ListIndexesWithResponse request
	ListIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error)

	// CreateIndexWithBodyWithResponse request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// CreateIndexForModelWithBodyWithResponse request with any body
	CreateIndexForModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error)

	CreateIndexForModelWithResponse(ctx context.Context, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error)

	// DeleteIndexWithResponse request
	DeleteIndexWithResponse(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// DescribeIndexWithResponse request
	DescribeIndexWithResponse(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*DescribeIndexResponse, error)

	// ConfigureIndexWithBodyWithResponse request with any body
	ConfigureIndexWithBodyWithResponse(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error)

	ConfigureIndexWithResponse(ctx context.Context, indexName string, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error)

	// ListIndexBackupsWithResponse request
	ListIndexBackupsWithResponse(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*ListIndexBackupsResponse, error)

	// CreateBackupWithBodyWithResponse request with any body
	CreateBackupWithBodyWithResponse(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	CreateBackupWithResponse(ctx context.Context, indexName string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	// ListRestoreJobsWithResponse request
	ListRestoreJobsWithResponse(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*ListRestoreJobsResponse, error)

	// DescribeRestoreJobWithResponse request
	DescribeRestoreJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DescribeRestoreJobResponse, error)
}

type ListProjectBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON412      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexFromBackupOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateIndexFromBackupResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexFromBackupOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexFromBackupOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CollectionModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexForModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexForModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexForModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON412      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfigureIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupList
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIndexBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BackupModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRestoreJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestoreJobList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListRestoreJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRestoreJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeRestoreJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestoreJobModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeRestoreJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeRestoreJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListProjectBackupsWithResponse request returning *ListProjectBackupsResponse
func (c *ClientWithResponses) ListProjectBackupsWithResponse(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectBackupsResponse, error) {
	rsp, err := c.ListProjectBackups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBackupsResponse(rsp)
}

// DeleteBackupWithResponse request returning *DeleteBackupResponse
func (c *ClientWithResponses) DeleteBackupWithResponse(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error) {
	rsp, err := c.DeleteBackup(ctx, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupResponse(rsp)
}

// DescribeBackupWithResponse request returning *DescribeBackupResponse
func (c *ClientWithResponses) DescribeBackupWithResponse(ctx context.Context, backupId string, reqEditors ...RequestEditorFn) (*DescribeBackupResponse, error) {
	rsp, err := c.DescribeBackup(ctx, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeBackupResponse(rsp)
}

// CreateIndexFromBackupOperationWithBodyWithResponse request with arbitrary body returning *CreateIndexFromBackupOperationResponse
func (c *ClientWithResponses) CreateIndexFromBackupOperationWithBodyWithResponse(ctx context.Context, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error) {
	rsp, err := c.CreateIndexFromBackupOperationWithBody(ctx, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexFromBackupOperationResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexFromBackupOperationWithResponse(ctx context.Context, backupId string, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error) {
	rsp, err := c.CreateIndexFromBackupOperation(ctx, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexFromBackupOperationResponse(rsp)
}

// ListCollectionsWithResponse request returning *ListCollectionsResponse
func (c *ClientWithResponses) ListCollectionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error) {
	rsp, err := c.ListCollections(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionsResponse(rsp)
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// DeleteCollectionWithResponse request returning *DeleteCollectionResponse
func (c *ClientWithResponses) DeleteCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error) {
	rsp, err := c.DeleteCollection(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionResponse(rsp)
}

// DescribeCollectionWithResponse request returning *DescribeCollectionResponse
func (c *ClientWithResponses) DescribeCollectionWithResponse(ctx context.Context, collectionName string, reqEditors ...RequestEditorFn) (*DescribeCollectionResponse, error) {
	rsp, err := c.DescribeCollection(ctx, collectionName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeCollectionResponse(rsp)
}

// ListIndexesWithResponse request returning *ListIndexesResponse
func (c *ClientWithResponses) ListIndexesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error) {
	rsp, err := c.ListIndexes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexesResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// CreateIndexForModelWithBodyWithResponse request with arbitrary body returning *CreateIndexForModelResponse
func (c *ClientWithResponses) CreateIndexForModelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error) {
	rsp, err := c.CreateIndexForModelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexForModelResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexForModelWithResponse(ctx context.Context, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error) {
	rsp, err := c.CreateIndexForModel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexForModelResponse(rsp)
}

// DeleteIndexWithResponse request returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, indexName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// DescribeIndexWithResponse request returning *DescribeIndexResponse
func (c *ClientWithResponses) DescribeIndexWithResponse(ctx context.Context, indexName string, reqEditors ...RequestEditorFn) (*DescribeIndexResponse, error) {
	rsp, err := c.DescribeIndex(ctx, indexName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeIndexResponse(rsp)
}

// ConfigureIndexWithBodyWithResponse request with arbitrary body returning *ConfigureIndexResponse
func (c *ClientWithResponses) ConfigureIndexWithBodyWithResponse(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error) {
	rsp, err := c.ConfigureIndexWithBody(ctx, indexName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureIndexResponse(rsp)
}

func (c *ClientWithResponses) ConfigureIndexWithResponse(ctx context.Context, indexName string, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error) {
	rsp, err := c.ConfigureIndex(ctx, indexName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureIndexResponse(rsp)
}

// ListIndexBackupsWithResponse request returning *ListIndexBackupsResponse
func (c *ClientWithResponses) ListIndexBackupsWithResponse(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*ListIndexBackupsResponse, error) {
	rsp, err := c.ListIndexBackups(ctx, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexBackupsResponse(rsp)
}

// CreateBackupWithBodyWithResponse request with arbitrary body returning *CreateBackupResponse
func (c *ClientWithResponses) CreateBackupWithBodyWithResponse(ctx context.Context, indexName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackupWithBody(ctx, indexName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

func (c *ClientWithResponses) CreateBackupWithResponse(ctx context.Context, indexName string, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackup(ctx, indexName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

// ListRestoreJobsWithResponse request returning *ListRestoreJobsResponse
func (c *ClientWithResponses) ListRestoreJobsWithResponse(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*ListRestoreJobsResponse, error) {
	rsp, err := c.ListRestoreJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRestoreJobsResponse(rsp)
}

// DescribeRestoreJobWithResponse request returning *DescribeRestoreJobResponse
func (c *ClientWithResponses) DescribeRestoreJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*DescribeRestoreJobResponse, error) {
	rsp, err := c.DescribeRestoreJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeRestoreJobResponse(rsp)
}

// ParseListProjectBackupsResponse parses an HTTP response from a ListProjectBackupsWithResponse call
func ParseListProjectBackupsResponse(rsp *http.Response) (*ListProjectBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBackupResponse parses an HTTP response from a DeleteBackupWithResponse call
func ParseDeleteBackupResponse(rsp *http.Response) (*DeleteBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeBackupResponse parses an HTTP response from a DescribeBackupWithResponse call
func ParseDescribeBackupResponse(rsp *http.Response) (*DescribeBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexFromBackupOperationResponse parses an HTTP response from a CreateIndexFromBackupOperationWithResponse call
func ParseCreateIndexFromBackupOperationResponse(rsp *http.Response) (*CreateIndexFromBackupOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexFromBackupOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateIndexFromBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCollectionsResponse parses an HTTP response from a ListCollectionsWithResponse call
func ParseListCollectionsResponse(rsp *http.Response) (*ListCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CollectionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionResponse parses an HTTP response from a DeleteCollectionWithResponse call
func ParseDeleteCollectionResponse(rsp *http.Response) (*DeleteCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeCollectionResponse parses an HTTP response from a DescribeCollectionWithResponse call
func ParseDescribeCollectionResponse(rsp *http.Response) (*DescribeCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexesResponse parses an HTTP response from a ListIndexesWithResponse call
func ParseListIndexesResponse(rsp *http.Response) (*ListIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexForModelResponse parses an HTTP response from a CreateIndexForModelWithResponse call
func ParseCreateIndexForModelResponse(rsp *http.Response) (*CreateIndexForModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexForModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeIndexResponse parses an HTTP response from a DescribeIndexWithResponse call
func ParseDescribeIndexResponse(rsp *http.Response) (*DescribeIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConfigureIndexResponse parses an HTTP response from a ConfigureIndexWithResponse call
func ParseConfigureIndexResponse(rsp *http.Response) (*ConfigureIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexBackupsResponse parses an HTTP response from a ListIndexBackupsWithResponse call
func ParseListIndexBackupsResponse(rsp *http.Response) (*ListIndexBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateBackupResponse parses an HTTP response from a CreateBackupWithResponse call
func ParseCreateBackupResponse(rsp *http.Response) (*CreateBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRestoreJobsResponse parses an HTTP response from a ListRestoreJobsWithResponse call
func ParseListRestoreJobsResponse(rsp *http.Response) (*ListRestoreJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRestoreJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestoreJobList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeRestoreJobResponse parses an HTTP response from a DescribeRestoreJobWithResponse call
func ParseDescribeRestoreJobResponse(rsp *http.Response) (*DescribeRestoreJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeRestoreJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestoreJobModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
