// Package db_control provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package db_control

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// BackupList The list of backups that exist in the project.
type BackupList struct {
	// Data List of backup objects
	Data *[]BackupModel `json:"data,omitempty"`

	// Pagination The pagination object that is returned with paginated responses.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// BackupModel The BackupModel describes the configuration and status of a Pinecone backup.
type BackupModel struct {
	// BackupId Unique identifier for the backup.
	BackupId string `json:"backup_id"`

	// Cloud Cloud provider where the backup is stored.
	Cloud string `json:"cloud"`

	// CreatedAt Timestamp when the backup was created.
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Optional description providing context for the backup.
	Description *string `json:"description,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	// Possible values: `cosine`, `euclidean`, or `dotproduct`.
	Metric *string `json:"metric,omitempty"`

	// Name Optional user-defined name for the backup.
	Name *string `json:"name,omitempty"`

	// NamespaceCount Number of namespaces in the backup.
	NamespaceCount *int `json:"namespace_count,omitempty"`

	// RecordCount Total number of records in the backup.
	RecordCount *int `json:"record_count,omitempty"`

	// Region Cloud region where the backup is stored.
	Region string `json:"region"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`

	// SizeBytes Size of the backup in bytes.
	SizeBytes *int `json:"size_bytes,omitempty"`

	// SourceIndexId ID of the index.
	SourceIndexId string `json:"source_index_id"`

	// SourceIndexName Name of the index from which the backup was taken.
	SourceIndexName string `json:"source_index_name"`

	// Status Current status of the backup (e.g., Initializing, Ready, Failed).
	Status string `json:"status"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// ByocSpec Configuration needed to deploy an index in a BYOC environment.
type ByocSpec struct {
	// Environment The environment where the index is hosted.
	Environment string `json:"environment"`

	// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
	ReadCapacity *ReadCapacity `json:"read_capacity,omitempty"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`
}

// ByocSpecResponse Configuration of a BYOC index.
type ByocSpecResponse struct {
	// Environment The environment where the index is hosted.
	Environment string `json:"environment"`

	// ReadCapacity Response containing read capacity configuration
	ReadCapacity ReadCapacityResponse `json:"read_capacity"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`
}

// CollectionList The list of collections that exist in the project.
type CollectionList struct {
	// Collections List of collections in the project
	Collections *[]CollectionModel `json:"collections,omitempty"`
}

// CollectionModel The CollectionModel describes the configuration and status of a Pinecone collection.
type CollectionModel struct {
	// Dimension The dimension of the vectors stored in each record held in the collection.
	Dimension *int32 `json:"dimension,omitempty"`

	// Environment The environment where the collection is hosted.
	Environment string `json:"environment"`

	// Name The name of the collection.
	Name string `json:"name"`

	// Size The size of the collection in bytes.
	Size *int64 `json:"size,omitempty"`

	// Status The status of the collection.
	// Possible values: `Initializing`, `Ready`, or `Terminating`.
	Status string `json:"status"`

	// VectorCount The number of records stored in the collection.
	VectorCount *int32 `json:"vector_count,omitempty"`
}

// ConfigureIndexRequest Configuration used to scale an index.
type ConfigureIndexRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	// Possible values: `disabled` or `enabled`.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Embed Configure the integrated inference embedding settings for this index.
	//
	// You can convert an existing index to an integrated index by specifying the embedding model and field_map. The index vector type and dimension must match the model vector type and dimension, and the index similarity metric must be supported by the model. Refer to the [model guide](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) for available models and model details.
	//
	// You can later change the embedding configuration to update the field map, read parameters, or write parameters. Once set, the model cannot be changed.
	Embed *struct {
		// FieldMap Identifies the name of the text field from your document model that will be embedded.
		FieldMap *map[string]interface{} `json:"field_map,omitempty"`

		// Model The name of the embedding model to use with the index. The index dimension and model dimension must match, and the index similarity metric must be supported by the model. The index embedding model cannot be changed once set.
		Model *string `json:"model,omitempty"`

		// ReadParameters The read parameters for the embedding model.
		ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

		// WriteParameters The write parameters for the embedding model.
		WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
	} `json:"embed,omitempty"`

	// Spec The spec object defines how the index should be deployed.  Only some attributes of an index's spec may be updated.  In general, you can modify settings related to scaling and  configuration but you cannot change the cloud or region  where the index is hosted.
	Spec *ConfigureIndexRequest_Spec `json:"spec,omitempty"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// ConfigureIndexRequestSpec0 defines model for .
type ConfigureIndexRequestSpec0 struct {
	// Serverless Updated configuration for serverless indexes
	Serverless struct {
		// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
		ReadCapacity *ReadCapacity `json:"read_capacity,omitempty"`
	} `json:"serverless"`
}

// ConfigureIndexRequestSpec1 defines model for .
type ConfigureIndexRequestSpec1 struct {
	// Pod Updated configuration for pod-based indexes
	Pod struct {
		// PodType The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
		PodType *string `json:"pod_type,omitempty"`

		// Replicas The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
		Replicas *int32 `json:"replicas,omitempty"`
	} `json:"pod"`
}

// ConfigureIndexRequestSpec2 defines model for .
type ConfigureIndexRequestSpec2 struct {
	// Byoc Updated configuration for a BYOC index
	Byoc struct {
		// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
		ReadCapacity *ReadCapacity `json:"read_capacity,omitempty"`
	} `json:"byoc"`
}

// ConfigureIndexRequest_Spec The spec object defines how the index should be deployed.  Only some attributes of an index's spec may be updated.  In general, you can modify settings related to scaling and  configuration but you cannot change the cloud or region  where the index is hosted.
type ConfigureIndexRequest_Spec struct {
	union json.RawMessage
}

// CreateBackupRequest The configuration needed to create a backup of an index.
type CreateBackupRequest struct {
	// Description A description of the backup.
	Description *string `json:"description,omitempty"`

	// Name The name of the backup.
	Name *string `json:"name,omitempty"`
}

// CreateCollectionRequest The configuration needed to create a Pinecone collection.
type CreateCollectionRequest struct {
	// Name The name of the collection to be created. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Source The name of the index to be used as the source for the collection.
	Source string `json:"source"`
}

// CreateIndexForModelRequest The desired configuration for the index and associated embedding model.
type CreateIndexForModelRequest struct {
	// Cloud The public cloud where you would like your index hosted.
	// Possible values: `gcp`, `aws`, or `azure`.
	Cloud string `json:"cloud"`

	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	// Possible values: `disabled` or `enabled`.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Embed Specify the integrated inference embedding configuration for the index.
	//
	// Once set the model cannot be changed, but you can later update the embedding configuration for an integrated inference index including field map, read parameters, or write parameters.
	//
	// Refer to the [model guide](https://docs.pinecone.io/guides/index-data/create-an-index#embedding-models) for available models and model details.
	Embed struct {
		// Dimension The dimension of embedding vectors produced for the index.
		Dimension *int `json:"dimension,omitempty"`

		// FieldMap Identifies the name of the text field from your document model that will be embedded.
		FieldMap map[string]interface{} `json:"field_map"`

		// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
		// Possible values: `cosine`, `euclidean`, or `dotproduct`.
		Metric *string `json:"metric,omitempty"`

		// Model The name of the embedding model to use for the index.
		Model string `json:"model"`

		// ReadParameters The read parameters for the embedding model.
		ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

		// WriteParameters The write parameters for the embedding model.
		WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
	} `json:"embed"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
	ReadCapacity *ReadCapacity `json:"read_capacity,omitempty"`

	// Region The region where you would like your index to be created.
	Region string `json:"region"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// CreateIndexFromBackupRequest The configuration needed to create a Pinecone index from a backup.
type CreateIndexFromBackupRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	// Possible values: `disabled` or `enabled`.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`
}

// CreateIndexFromBackupResponse The response for creating an index from a backup.
type CreateIndexFromBackupResponse struct {
	// IndexId The ID of the index that was created from the backup.
	IndexId string `json:"index_id"`

	// RestoreJobId The ID of the restore job that was created.
	RestoreJobId string `json:"restore_job_id"`
}

// CreateIndexRequest The configuration needed to create a Pinecone index.
type CreateIndexRequest struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	// Possible values: `disabled` or `enabled`.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	// Possible values: `cosine`, `euclidean`, or `dotproduct`.
	Metric *string `json:"metric,omitempty"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// Spec The spec object defines how the index should be deployed.
	//
	// For serverless indexes, you define only the [cloud and region](http://docs.pinecone.io/guides/index-data/create-an-index#cloud-regions) where the index should be hosted. For pod-based indexes, you define the [environment](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-environments) where the index should be hosted, the [pod type and size](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-types) to use, and other index characteristics.
	Spec IndexSpec `json:"spec"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType *string `json:"vector_type,omitempty"`
}

// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
// Possible values: `disabled` or `enabled`.
type DeletionProtection = string

// ErrorResponse The response shape used for all error responses.
type ErrorResponse struct {
	// Error Detailed information about the error that occurred.
	Error struct {
		// Code The error code.
		// Possible values: `OK`, `UNKNOWN`, `INVALID_ARGUMENT`, `DEADLINE_EXCEEDED`, `QUOTA_EXCEEDED`, `NOT_FOUND`, `ALREADY_EXISTS`, `PERMISSION_DENIED`, `UNAUTHENTICATED`, `RESOURCE_EXHAUSTED`, `FAILED_PRECONDITION`, `ABORTED`, `OUT_OF_RANGE`, `UNIMPLEMENTED`, `INTERNAL`, `UNAVAILABLE`, `DATA_LOSS`, `FORBIDDEN`, `UNPROCESSABLE_ENTITY`, or `PAYMENT_REQUIRED`.
		Code string `json:"code"`

		// Details Additional information about the error. This field is not guaranteed to be present.
		Details *map[string]interface{} `json:"details,omitempty"`

		// Message A human-readable description of the error
		Message string `json:"message"`
	} `json:"error"`

	// Status The HTTP status code of the error.
	Status int `json:"status"`
}

// IndexList The list of indexes that exist in the project.
type IndexList struct {
	// Indexes List of indexes in the project
	Indexes *[]IndexModel `json:"indexes,omitempty"`
}

// IndexModel The IndexModel describes the configuration and status of a Pinecone index.
type IndexModel struct {
	// DeletionProtection Whether [deletion protection](http://docs.pinecone.io/guides/manage-data/manage-indexes#configure-deletion-protection) is enabled/disabled for the index.
	// Possible values: `disabled` or `enabled`.
	DeletionProtection *DeletionProtection `json:"deletion_protection,omitempty"`

	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// Embed The embedding model and document fields mapped to embedding inputs.
	Embed *ModelIndexEmbed `json:"embed,omitempty"`

	// Host The URL address where the index is hosted.
	Host string `json:"host"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If the 'vector_type' is 'sparse', the metric must be 'dotproduct'. If the `vector_type` is `dense`, the metric defaults to 'cosine'.
	// Possible values: `cosine`, `euclidean`, or `dotproduct`.
	Metric string `json:"metric"`

	// Name The name of the index. Resource name must be 1-45 characters long, start and end with an alphanumeric character, and consist only of lower case alphanumeric characters or '-'.
	Name string `json:"name"`

	// PrivateHost The private endpoint URL of an index.
	PrivateHost *string `json:"private_host,omitempty"`

	// Spec The spec object defines how the index should be deployed.
	Spec IndexModel_Spec `json:"spec"`

	// Status The current status of the index
	Status struct {
		// Ready Whether the index is ready for use
		Ready bool `json:"ready"`

		// State The state of the index.
		// Possible values: `Initializing`, `InitializationFailed`, `ScalingUp`, `ScalingDown`, `ScalingUpPodSize`, `ScalingDownPodSize`, `Terminating`, `Ready`, or `Disabled`.
		State string `json:"state"`
	} `json:"status"`

	// Tags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
	Tags *IndexTags `json:"tags,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType string `json:"vector_type"`
}

// IndexModelSpec0 defines model for .
type IndexModelSpec0 struct {
	// Serverless Configuration of a serverless index.
	Serverless ServerlessSpecResponse `json:"serverless"`
}

// IndexModelSpec1 defines model for .
type IndexModelSpec1 struct {
	// Pod Configuration needed to deploy a pod-based index.
	Pod PodSpec `json:"pod"`
}

// IndexModelSpec2 defines model for .
type IndexModelSpec2 struct {
	// Byoc Configuration of a BYOC index.
	Byoc ByocSpecResponse `json:"byoc"`
}

// IndexModel_Spec The spec object defines how the index should be deployed.
type IndexModel_Spec struct {
	union json.RawMessage
}

// IndexSpec The spec object defines how the index should be deployed.
//
// For serverless indexes, you define only the [cloud and region](http://docs.pinecone.io/guides/index-data/create-an-index#cloud-regions) where the index should be hosted. For pod-based indexes, you define the [environment](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-environments) where the index should be hosted, the [pod type and size](http://docs.pinecone.io/guides/indexes/pods/understanding-pod-based-indexes#pod-types) to use, and other index characteristics.
type IndexSpec struct {
	union json.RawMessage
}

// IndexSpec0 defines model for .
type IndexSpec0 struct {
	// Serverless Configuration needed to deploy a serverless index.
	Serverless ServerlessSpec `json:"serverless"`
}

// IndexSpec1 defines model for .
type IndexSpec1 struct {
	// Pod Configuration needed to deploy a pod-based index.
	Pod PodSpec `json:"pod"`
}

// IndexSpec2 defines model for .
type IndexSpec2 struct {
	// Byoc Configuration needed to deploy an index in a BYOC environment.
	Byoc ByocSpec `json:"byoc"`
}

// IndexTags Custom user tags added to an index. Keys must be 80 characters or less. Values must be 120 characters or less. Keys must be alphanumeric, '_', or '-'.  Values must be alphanumeric, ';', '@', '_', '-', '.', '+', or ' '. To unset a key, set the value to be an empty string.
type IndexTags map[string]string

// MetadataSchema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
type MetadataSchema struct {
	// Fields A map of metadata field names to their configuration. The field name must be a valid metadata field name. The field name must be unique.
	Fields map[string]struct {
		// Filterable Whether the field is filterable. If true, the field is indexed and can be used in filters. Only true values are allowed.
		Filterable *bool `json:"filterable,omitempty"`
	} `json:"fields"`
}

// ModelIndexEmbed The embedding model and document fields mapped to embedding inputs.
type ModelIndexEmbed struct {
	// Dimension The dimensions of the vectors to be inserted in the index.
	Dimension *int32 `json:"dimension,omitempty"`

	// FieldMap Identifies the name of the text field from your document model that is embedded.
	FieldMap *map[string]interface{} `json:"field_map,omitempty"`

	// Metric The distance metric to be used for similarity search. You can use 'euclidean', 'cosine', or 'dotproduct'. If not specified, the metric will be defaulted according to the model. Cannot be updated once set.
	// Possible values: `cosine`, `euclidean`, or `dotproduct`.
	Metric *string `json:"metric,omitempty"`

	// Model The name of the embedding model used to create the index.
	Model string `json:"model"`

	// ReadParameters The read parameters for the embedding model.
	ReadParameters *map[string]interface{} `json:"read_parameters,omitempty"`

	// VectorType The index vector type. You can use 'dense' or 'sparse'. If 'dense', the vector dimension must be specified.  If 'sparse', the vector dimension should not be specified.
	VectorType *string `json:"vector_type,omitempty"`

	// WriteParameters The write parameters for the embedding model.
	WriteParameters *map[string]interface{} `json:"write_parameters,omitempty"`
}

// PaginationResponse The pagination object that is returned with paginated responses.
type PaginationResponse struct {
	// Next The token to use to retrieve the next page of results.
	Next string `json:"next"`
}

// PodSpec Configuration needed to deploy a pod-based index.
type PodSpec struct {
	// Environment The environment where the index is hosted.
	Environment string `json:"environment"`

	// MetadataConfig Configuration for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `metadata_config` is present, only specified metadata fields are indexed. These configurations are only valid for use with pod-based indexes.
	MetadataConfig *struct {
		// Indexed By default, all metadata is indexed; to change this behavior, use this property to specify an array of metadata fields that should be indexed.
		Indexed *[]string `json:"indexed,omitempty"`
	} `json:"metadata_config,omitempty"`

	// PodType The type of pod to use. One of `s1`, `p1`, or `p2` appended with `.` and one of `x1`, `x2`, `x4`, or `x8`.
	PodType string `json:"pod_type"`

	// Pods The number of pods to be used in the index. This should be equal to `shards` x `replicas`.'
	Pods *int `json:"pods,omitempty"`

	// Replicas The number of replicas. Replicas duplicate your index. They provide higher availability and throughput. Replicas can be scaled up or down as your needs change.
	Replicas *int32 `json:"replicas,omitempty"`

	// Shards The number of shards. Shards split your data across multiple pods so you can fit more data into an index.
	Shards *int32 `json:"shards,omitempty"`

	// SourceCollection The name of the collection to be used as the source for the index.
	SourceCollection *string `json:"source_collection,omitempty"`
}

// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
type ReadCapacity struct {
	union json.RawMessage
}

// ReadCapacityDedicatedConfig Configuration for dedicated read capacity. See  [this guide](https://docs.pinecone.io/guides/index-data/dedicated-read-nodes) for more details on  how to configure dedicated read capacity.
type ReadCapacityDedicatedConfig struct {
	// Manual The config to use for manual read capacity scaling.
	Manual *ScalingConfigManual `json:"manual,omitempty"`

	// NodeType The type of machines to use. Available options: `b1` and `t1`. `t1` includes increased processing power and memory.
	NodeType *string `json:"node_type,omitempty"`

	// Scaling The type of scaling strategy to use.
	Scaling *string `json:"scaling,omitempty"`
}

// ReadCapacityDedicatedSpec defines model for ReadCapacityDedicatedSpec.
type ReadCapacityDedicatedSpec struct {
	// Dedicated Configuration for dedicated read capacity. See  [this guide](https://docs.pinecone.io/guides/index-data/dedicated-read-nodes) for more details on  how to configure dedicated read capacity.
	Dedicated ReadCapacityDedicatedConfig `json:"dedicated"`

	// Mode The mode of the index. Possible values: `OnDemand` or `Dedicated`. Defaults to `OnDemand`. If set to `Dedicated`, `dedicated.node_type`, and `dedicated.scaling` must be specified.
	Mode                 string                 `json:"mode"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// ReadCapacityDedicatedSpecResponse defines model for ReadCapacityDedicatedSpecResponse.
type ReadCapacityDedicatedSpecResponse struct {
	// Dedicated Configuration for dedicated read capacity. See  [this guide](https://docs.pinecone.io/guides/index-data/dedicated-read-nodes) for more details on  how to configure dedicated read capacity.
	Dedicated ReadCapacityDedicatedConfig `json:"dedicated"`

	// Mode The mode of the index. Possible values: `OnDemand` or `Dedicated`. Defaults to `OnDemand`. If set to `Dedicated`, `dedicated.node_type`, and `dedicated.scaling` must be specified.
	Mode string `json:"mode"`

	// Status The current status of factors affecting the read capacity of a serverless index
	Status ReadCapacityStatus `json:"status"`
}

// ReadCapacityOnDemandSpec defines model for ReadCapacityOnDemandSpec.
type ReadCapacityOnDemandSpec struct {
	// Mode The mode of the index. Possible values: `OnDemand` or `Dedicated`. Defaults to `OnDemand`. If set to `Dedicated`, `dedicated.node_type`, and `dedicated.scaling` must be specified.
	Mode string `json:"mode"`
}

// ReadCapacityOnDemandSpecResponse defines model for ReadCapacityOnDemandSpecResponse.
type ReadCapacityOnDemandSpecResponse struct {
	// Mode The mode of the index. Possible values: `OnDemand` or `Dedicated`. Defaults to `OnDemand`. If set to `Dedicated`, `dedicated.node_type`, and `dedicated.scaling` must be specified.
	Mode string `json:"mode"`

	// Status The current status of factors affecting the read capacity of a serverless index
	Status ReadCapacityStatus `json:"status"`
}

// ReadCapacityResponse Response containing read capacity configuration
type ReadCapacityResponse struct {
	union json.RawMessage
}

// ReadCapacityStatus The current status of factors affecting the read capacity of a serverless index
type ReadCapacityStatus struct {
	// CurrentReplicas The number of replicas. Each replica has dedicated  compute resources and data storage. Increasing this number  will increase the total throughput of the index.
	CurrentReplicas *int32 `json:"current_replicas,omitempty"`

	// CurrentShards The number of shards. Each shard has dedicated storage.  Increasing shards alleiviates index fullness.
	CurrentShards *int32 `json:"current_shards,omitempty"`

	// ErrorMessage An optional error message indicating any issues with your read capacity configuration
	ErrorMessage *string `json:"error_message,omitempty"`

	// State The `state` describes the overall status of factors relating to the read capacity of an index.
	//
	// Available values:
	// - `Ready` is the state most of the time
	// - `Scaling` if the number of replicas or shards has been recently updated by calling the [configure index endpoint](https://docs.pinecone.io/reference/api/2025-10/control-plane/configure_index)
	// - `Migrating` if the index is being migrated to a new `node_type`
	// - `Error` if there is an error with the read capacity configuration. In that case, see `error_message` for more details.
	State string `json:"state"`
}

// RestoreJobList The list of restore jobs that exist in the project.
type RestoreJobList struct {
	// Data List of restore job objects
	Data []RestoreJobModel `json:"data"`

	// Pagination The pagination object that is returned with paginated responses.
	Pagination *PaginationResponse `json:"pagination,omitempty"`
}

// RestoreJobModel The RestoreJobModel describes the status of a restore job.
type RestoreJobModel struct {
	// BackupId Backup used for the restore
	BackupId string `json:"backup_id"`

	// CompletedAt Timestamp when the restore job finished
	CompletedAt *time.Time `json:"completed_at,omitempty"`

	// CreatedAt Timestamp when the restore job started
	CreatedAt time.Time `json:"created_at"`

	// PercentComplete The progress made by the restore job out of 100
	PercentComplete *float32 `json:"percent_complete,omitempty"`

	// RestoreJobId Unique identifier for the restore job
	RestoreJobId string `json:"restore_job_id"`

	// Status Status of the restore job
	Status string `json:"status"`

	// TargetIndexId ID of the index
	TargetIndexId string `json:"target_index_id"`

	// TargetIndexName Name of the index into which data is being restored
	TargetIndexName string `json:"target_index_name"`
}

// ScalingConfigManual The config to use for manual read capacity scaling.
type ScalingConfigManual struct {
	// Replicas The number of replicas to use. Replicas duplicate the compute resources and data of an index, allowing higher query throughput and availability. Setting replicas to 0 disables the index but can be used to reduce costs while usage is paused.
	Replicas *int32 `json:"replicas,omitempty"`

	// Shards The number of shards to use. Shards determine the storage capacity of an index, with each shard providing 250 GB of storage.
	Shards *int32 `json:"shards,omitempty"`
}

// ServerlessSpec Configuration needed to deploy a serverless index.
type ServerlessSpec struct {
	// Cloud The public cloud where you would like your index hosted.
	// Possible values: `gcp`, `aws`, or `azure`.
	Cloud string `json:"cloud"`

	// ReadCapacity By default the index will be created with read capacity  mode `OnDemand`. If you prefer to allocate dedicated read  nodes for your workload, you must specify mode `Dedicated` and additional configurations for `node_type` and `scaling`.
	ReadCapacity *ReadCapacity `json:"read_capacity,omitempty"`

	// Region The region where you would like your index to be created.
	Region string `json:"region"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`

	// SourceCollection The name of the collection to be used as the source for the index.
	SourceCollection *string `json:"source_collection,omitempty"`
}

// ServerlessSpecResponse Configuration of a serverless index.
type ServerlessSpecResponse struct {
	// Cloud The public cloud where you would like your index hosted.
	// Possible values: `gcp`, `aws`, or `azure`.
	Cloud string `json:"cloud"`

	// ReadCapacity Response containing read capacity configuration
	ReadCapacity ReadCapacityResponse `json:"read_capacity"`

	// Region The region where you would like your index to be created.
	Region string `json:"region"`

	// Schema Schema for the behavior of Pinecone's internal metadata index. By default, all metadata is indexed; when `schema` is present, only fields which are present in the `fields` object with a `filterable: true` are indexed. Note that `filterable: false` is not currently supported.
	Schema *MetadataSchema `json:"schema,omitempty"`

	// SourceCollection The name of the collection to be used as the source for the index.
	SourceCollection *string `json:"source_collection,omitempty"`
}

// ListProjectBackupsParams defines parameters for ListProjectBackups.
type ListProjectBackupsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DeleteBackupParams defines parameters for DeleteBackup.
type DeleteBackupParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DescribeBackupParams defines parameters for DescribeBackup.
type DescribeBackupParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateIndexFromBackupOperationParams defines parameters for CreateIndexFromBackupOperation.
type CreateIndexFromBackupOperationParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateCollectionParams defines parameters for CreateCollection.
type CreateCollectionParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DeleteCollectionParams defines parameters for DeleteCollection.
type DeleteCollectionParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DescribeCollectionParams defines parameters for DescribeCollection.
type DescribeCollectionParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// ListIndexesParams defines parameters for ListIndexes.
type ListIndexesParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateIndexParams defines parameters for CreateIndex.
type CreateIndexParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateIndexForModelParams defines parameters for CreateIndexForModel.
type CreateIndexForModelParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DeleteIndexParams defines parameters for DeleteIndex.
type DeleteIndexParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DescribeIndexParams defines parameters for DescribeIndex.
type DescribeIndexParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// ConfigureIndexParams defines parameters for ConfigureIndex.
type ConfigureIndexParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// ListIndexBackupsParams defines parameters for ListIndexBackups.
type ListIndexBackupsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateBackupParams defines parameters for CreateBackup.
type CreateBackupParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// ListRestoreJobsParams defines parameters for ListRestoreJobs.
type ListRestoreJobsParams struct {
	// Limit The number of results to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken The token to use to retrieve the next page of results.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`

	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// DescribeRestoreJobParams defines parameters for DescribeRestoreJob.
type DescribeRestoreJobParams struct {
	// XPineconeApiVersion Required date-based version header
	XPineconeApiVersion string `json:"X-Pinecone-Api-Version"`
}

// CreateIndexFromBackupOperationJSONRequestBody defines body for CreateIndexFromBackupOperation for application/json ContentType.
type CreateIndexFromBackupOperationJSONRequestBody = CreateIndexFromBackupRequest

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollectionRequest

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = CreateIndexRequest

// CreateIndexForModelJSONRequestBody defines body for CreateIndexForModel for application/json ContentType.
type CreateIndexForModelJSONRequestBody = CreateIndexForModelRequest

// ConfigureIndexJSONRequestBody defines body for ConfigureIndex for application/json ContentType.
type ConfigureIndexJSONRequestBody = ConfigureIndexRequest

// CreateBackupJSONRequestBody defines body for CreateBackup for application/json ContentType.
type CreateBackupJSONRequestBody = CreateBackupRequest

// Getter for additional properties for ReadCapacityDedicatedSpec. Returns the specified
// element and whether it was found
func (a ReadCapacityDedicatedSpec) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ReadCapacityDedicatedSpec
func (a *ReadCapacityDedicatedSpec) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ReadCapacityDedicatedSpec to handle AdditionalProperties
func (a *ReadCapacityDedicatedSpec) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dedicated"]; found {
		err = json.Unmarshal(raw, &a.Dedicated)
		if err != nil {
			return fmt.Errorf("error reading 'dedicated': %w", err)
		}
		delete(object, "dedicated")
	}

	if raw, found := object["mode"]; found {
		err = json.Unmarshal(raw, &a.Mode)
		if err != nil {
			return fmt.Errorf("error reading 'mode': %w", err)
		}
		delete(object, "mode")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ReadCapacityDedicatedSpec to handle AdditionalProperties
func (a ReadCapacityDedicatedSpec) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["dedicated"], err = json.Marshal(a.Dedicated)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'dedicated': %w", err)
	}

	object["mode"], err = json.Marshal(a.Mode)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mode': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsConfigureIndexRequestSpec0 returns the union data inside the ConfigureIndexRequest_Spec as a ConfigureIndexRequestSpec0
func (t ConfigureIndexRequest_Spec) AsConfigureIndexRequestSpec0() (ConfigureIndexRequestSpec0, error) {
	var body ConfigureIndexRequestSpec0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigureIndexRequestSpec0 overwrites any union data inside the ConfigureIndexRequest_Spec as the provided ConfigureIndexRequestSpec0
func (t *ConfigureIndexRequest_Spec) FromConfigureIndexRequestSpec0(v ConfigureIndexRequestSpec0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigureIndexRequestSpec0 performs a merge with any union data inside the ConfigureIndexRequest_Spec, using the provided ConfigureIndexRequestSpec0
func (t *ConfigureIndexRequest_Spec) MergeConfigureIndexRequestSpec0(v ConfigureIndexRequestSpec0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfigureIndexRequestSpec1 returns the union data inside the ConfigureIndexRequest_Spec as a ConfigureIndexRequestSpec1
func (t ConfigureIndexRequest_Spec) AsConfigureIndexRequestSpec1() (ConfigureIndexRequestSpec1, error) {
	var body ConfigureIndexRequestSpec1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigureIndexRequestSpec1 overwrites any union data inside the ConfigureIndexRequest_Spec as the provided ConfigureIndexRequestSpec1
func (t *ConfigureIndexRequest_Spec) FromConfigureIndexRequestSpec1(v ConfigureIndexRequestSpec1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigureIndexRequestSpec1 performs a merge with any union data inside the ConfigureIndexRequest_Spec, using the provided ConfigureIndexRequestSpec1
func (t *ConfigureIndexRequest_Spec) MergeConfigureIndexRequestSpec1(v ConfigureIndexRequestSpec1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfigureIndexRequestSpec2 returns the union data inside the ConfigureIndexRequest_Spec as a ConfigureIndexRequestSpec2
func (t ConfigureIndexRequest_Spec) AsConfigureIndexRequestSpec2() (ConfigureIndexRequestSpec2, error) {
	var body ConfigureIndexRequestSpec2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigureIndexRequestSpec2 overwrites any union data inside the ConfigureIndexRequest_Spec as the provided ConfigureIndexRequestSpec2
func (t *ConfigureIndexRequest_Spec) FromConfigureIndexRequestSpec2(v ConfigureIndexRequestSpec2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigureIndexRequestSpec2 performs a merge with any union data inside the ConfigureIndexRequest_Spec, using the provided ConfigureIndexRequestSpec2
func (t *ConfigureIndexRequest_Spec) MergeConfigureIndexRequestSpec2(v ConfigureIndexRequestSpec2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfigureIndexRequest_Spec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfigureIndexRequest_Spec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndexModelSpec0 returns the union data inside the IndexModel_Spec as a IndexModelSpec0
func (t IndexModel_Spec) AsIndexModelSpec0() (IndexModelSpec0, error) {
	var body IndexModelSpec0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexModelSpec0 overwrites any union data inside the IndexModel_Spec as the provided IndexModelSpec0
func (t *IndexModel_Spec) FromIndexModelSpec0(v IndexModelSpec0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexModelSpec0 performs a merge with any union data inside the IndexModel_Spec, using the provided IndexModelSpec0
func (t *IndexModel_Spec) MergeIndexModelSpec0(v IndexModelSpec0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexModelSpec1 returns the union data inside the IndexModel_Spec as a IndexModelSpec1
func (t IndexModel_Spec) AsIndexModelSpec1() (IndexModelSpec1, error) {
	var body IndexModelSpec1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexModelSpec1 overwrites any union data inside the IndexModel_Spec as the provided IndexModelSpec1
func (t *IndexModel_Spec) FromIndexModelSpec1(v IndexModelSpec1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexModelSpec1 performs a merge with any union data inside the IndexModel_Spec, using the provided IndexModelSpec1
func (t *IndexModel_Spec) MergeIndexModelSpec1(v IndexModelSpec1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexModelSpec2 returns the union data inside the IndexModel_Spec as a IndexModelSpec2
func (t IndexModel_Spec) AsIndexModelSpec2() (IndexModelSpec2, error) {
	var body IndexModelSpec2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexModelSpec2 overwrites any union data inside the IndexModel_Spec as the provided IndexModelSpec2
func (t *IndexModel_Spec) FromIndexModelSpec2(v IndexModelSpec2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexModelSpec2 performs a merge with any union data inside the IndexModel_Spec, using the provided IndexModelSpec2
func (t *IndexModel_Spec) MergeIndexModelSpec2(v IndexModelSpec2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndexModel_Spec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IndexModel_Spec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIndexSpec0 returns the union data inside the IndexSpec as a IndexSpec0
func (t IndexSpec) AsIndexSpec0() (IndexSpec0, error) {
	var body IndexSpec0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec0 overwrites any union data inside the IndexSpec as the provided IndexSpec0
func (t *IndexSpec) FromIndexSpec0(v IndexSpec0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec0 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec0
func (t *IndexSpec) MergeIndexSpec0(v IndexSpec0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexSpec1 returns the union data inside the IndexSpec as a IndexSpec1
func (t IndexSpec) AsIndexSpec1() (IndexSpec1, error) {
	var body IndexSpec1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec1 overwrites any union data inside the IndexSpec as the provided IndexSpec1
func (t *IndexSpec) FromIndexSpec1(v IndexSpec1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec1 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec1
func (t *IndexSpec) MergeIndexSpec1(v IndexSpec1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexSpec2 returns the union data inside the IndexSpec as a IndexSpec2
func (t IndexSpec) AsIndexSpec2() (IndexSpec2, error) {
	var body IndexSpec2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexSpec2 overwrites any union data inside the IndexSpec as the provided IndexSpec2
func (t *IndexSpec) FromIndexSpec2(v IndexSpec2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexSpec2 performs a merge with any union data inside the IndexSpec, using the provided IndexSpec2
func (t *IndexSpec) MergeIndexSpec2(v IndexSpec2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IndexSpec) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IndexSpec) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReadCapacityOnDemandSpec returns the union data inside the ReadCapacity as a ReadCapacityOnDemandSpec
func (t ReadCapacity) AsReadCapacityOnDemandSpec() (ReadCapacityOnDemandSpec, error) {
	var body ReadCapacityOnDemandSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadCapacityOnDemandSpec overwrites any union data inside the ReadCapacity as the provided ReadCapacityOnDemandSpec
func (t *ReadCapacity) FromReadCapacityOnDemandSpec(v ReadCapacityOnDemandSpec) error {
	v.Mode = "OnDemand"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadCapacityOnDemandSpec performs a merge with any union data inside the ReadCapacity, using the provided ReadCapacityOnDemandSpec
func (t *ReadCapacity) MergeReadCapacityOnDemandSpec(v ReadCapacityOnDemandSpec) error {
	v.Mode = "OnDemand"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReadCapacityDedicatedSpec returns the union data inside the ReadCapacity as a ReadCapacityDedicatedSpec
func (t ReadCapacity) AsReadCapacityDedicatedSpec() (ReadCapacityDedicatedSpec, error) {
	var body ReadCapacityDedicatedSpec
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadCapacityDedicatedSpec overwrites any union data inside the ReadCapacity as the provided ReadCapacityDedicatedSpec
func (t *ReadCapacity) FromReadCapacityDedicatedSpec(v ReadCapacityDedicatedSpec) error {
	v.Mode = "Dedicated"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadCapacityDedicatedSpec performs a merge with any union data inside the ReadCapacity, using the provided ReadCapacityDedicatedSpec
func (t *ReadCapacity) MergeReadCapacityDedicatedSpec(v ReadCapacityDedicatedSpec) error {
	v.Mode = "Dedicated"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReadCapacity) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"mode"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ReadCapacity) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Dedicated":
		return t.AsReadCapacityDedicatedSpec()
	case "OnDemand":
		return t.AsReadCapacityOnDemandSpec()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ReadCapacity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReadCapacity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReadCapacityOnDemandSpecResponse returns the union data inside the ReadCapacityResponse as a ReadCapacityOnDemandSpecResponse
func (t ReadCapacityResponse) AsReadCapacityOnDemandSpecResponse() (ReadCapacityOnDemandSpecResponse, error) {
	var body ReadCapacityOnDemandSpecResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadCapacityOnDemandSpecResponse overwrites any union data inside the ReadCapacityResponse as the provided ReadCapacityOnDemandSpecResponse
func (t *ReadCapacityResponse) FromReadCapacityOnDemandSpecResponse(v ReadCapacityOnDemandSpecResponse) error {
	v.Mode = "OnDemand"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadCapacityOnDemandSpecResponse performs a merge with any union data inside the ReadCapacityResponse, using the provided ReadCapacityOnDemandSpecResponse
func (t *ReadCapacityResponse) MergeReadCapacityOnDemandSpecResponse(v ReadCapacityOnDemandSpecResponse) error {
	v.Mode = "OnDemand"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReadCapacityDedicatedSpecResponse returns the union data inside the ReadCapacityResponse as a ReadCapacityDedicatedSpecResponse
func (t ReadCapacityResponse) AsReadCapacityDedicatedSpecResponse() (ReadCapacityDedicatedSpecResponse, error) {
	var body ReadCapacityDedicatedSpecResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReadCapacityDedicatedSpecResponse overwrites any union data inside the ReadCapacityResponse as the provided ReadCapacityDedicatedSpecResponse
func (t *ReadCapacityResponse) FromReadCapacityDedicatedSpecResponse(v ReadCapacityDedicatedSpecResponse) error {
	v.Mode = "Dedicated"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReadCapacityDedicatedSpecResponse performs a merge with any union data inside the ReadCapacityResponse, using the provided ReadCapacityDedicatedSpecResponse
func (t *ReadCapacityResponse) MergeReadCapacityDedicatedSpecResponse(v ReadCapacityDedicatedSpecResponse) error {
	v.Mode = "Dedicated"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReadCapacityResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"mode"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ReadCapacityResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Dedicated":
		return t.AsReadCapacityDedicatedSpecResponse()
	case "OnDemand":
		return t.AsReadCapacityOnDemandSpecResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ReadCapacityResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReadCapacityResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListProjectBackups request
	ListProjectBackups(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackup request
	DeleteBackup(ctx context.Context, backupId string, params *DeleteBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeBackup request
	DescribeBackup(ctx context.Context, backupId string, params *DescribeBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexFromBackupOperationWithBody request with any body
	CreateIndexFromBackupOperationWithBody(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndexFromBackupOperation(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollections request
	ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollectionWithBody request with any body
	CreateCollectionWithBody(ctx context.Context, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollection request
	DeleteCollection(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeCollection request
	DescribeCollection(ctx context.Context, collectionName string, params *DescribeCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexes request
	ListIndexes(ctx context.Context, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexWithBody request with any body
	CreateIndexWithBody(ctx context.Context, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndexForModelWithBody request with any body
	CreateIndexForModelWithBody(ctx context.Context, params *CreateIndexForModelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndexForModel(ctx context.Context, params *CreateIndexForModelParams, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request
	DeleteIndex(ctx context.Context, indexName string, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeIndex request
	DescribeIndex(ctx context.Context, indexName string, params *DescribeIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigureIndexWithBody request with any body
	ConfigureIndexWithBody(ctx context.Context, indexName string, params *ConfigureIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConfigureIndex(ctx context.Context, indexName string, params *ConfigureIndexParams, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIndexBackups request
	ListIndexBackups(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackupWithBody request with any body
	CreateBackupWithBody(ctx context.Context, indexName string, params *CreateBackupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackup(ctx context.Context, indexName string, params *CreateBackupParams, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRestoreJobs request
	ListRestoreJobs(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeRestoreJob request
	DescribeRestoreJob(ctx context.Context, jobId string, params *DescribeRestoreJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListProjectBackups(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectBackupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackup(ctx context.Context, backupId string, params *DeleteBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackupRequest(c.Server, backupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeBackup(ctx context.Context, backupId string, params *DescribeBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeBackupRequest(c.Server, backupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexFromBackupOperationWithBody(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexFromBackupOperationRequestWithBody(c.Server, backupId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexFromBackupOperation(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexFromBackupOperationRequest(c.Server, backupId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollection(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionRequest(c.Server, collectionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeCollection(ctx context.Context, collectionName string, params *DescribeCollectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeCollectionRequest(c.Server, collectionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexes(ctx context.Context, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexForModelWithBody(ctx context.Context, params *CreateIndexForModelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexForModelRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexForModel(ctx context.Context, params *CreateIndexForModelParams, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexForModelRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, indexName string, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeIndex(ctx context.Context, indexName string, params *DescribeIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeIndexRequest(c.Server, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureIndexWithBody(ctx context.Context, indexName string, params *ConfigureIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureIndexRequestWithBody(c.Server, indexName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigureIndex(ctx context.Context, indexName string, params *ConfigureIndexParams, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigureIndexRequest(c.Server, indexName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIndexBackups(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIndexBackupsRequest(c.Server, indexName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackupWithBody(ctx context.Context, indexName string, params *CreateBackupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequestWithBody(c.Server, indexName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackup(ctx context.Context, indexName string, params *CreateBackupParams, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequest(c.Server, indexName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRestoreJobs(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRestoreJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeRestoreJob(ctx context.Context, jobId string, params *DescribeRestoreJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeRestoreJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListProjectBackupsRequest generates requests for ListProjectBackups
func NewListProjectBackupsRequest(server string, params *ListProjectBackupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDeleteBackupRequest generates requests for DeleteBackup
func NewDeleteBackupRequest(server string, backupId string, params *DeleteBackupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDescribeBackupRequest generates requests for DescribeBackup
func NewDescribeBackupRequest(server string, backupId string, params *DescribeBackupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewCreateIndexFromBackupOperationRequest calls the generic CreateIndexFromBackupOperation builder with application/json body
func NewCreateIndexFromBackupOperationRequest(server string, backupId string, params *CreateIndexFromBackupOperationParams, body CreateIndexFromBackupOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexFromBackupOperationRequestWithBody(server, backupId, params, "application/json", bodyReader)
}

// NewCreateIndexFromBackupOperationRequestWithBody generates requests for CreateIndexFromBackupOperation with any type of body
func NewCreateIndexFromBackupOperationRequestWithBody(server string, backupId string, params *CreateIndexFromBackupOperationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "backup_id", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/backups/%s/create-index", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewListCollectionsRequest generates requests for ListCollections
func NewListCollectionsRequest(server string, params *ListCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, params *CreateCollectionParams, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, params *CreateCollectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDeleteCollectionRequest generates requests for DeleteCollection
func NewDeleteCollectionRequest(server string, collectionName string, params *DeleteCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDescribeCollectionRequest generates requests for DescribeCollection
func NewDescribeCollectionRequest(server string, collectionName string, params *DescribeCollectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collection_name", runtime.ParamLocationPath, collectionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewListIndexesRequest generates requests for ListIndexes
func NewListIndexesRequest(server string, params *ListIndexesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, params *CreateIndexParams, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, params *CreateIndexParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewCreateIndexForModelRequest calls the generic CreateIndexForModel builder with application/json body
func NewCreateIndexForModelRequest(server string, params *CreateIndexForModelParams, body CreateIndexForModelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexForModelRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateIndexForModelRequestWithBody generates requests for CreateIndexForModel with any type of body
func NewCreateIndexForModelRequestWithBody(server string, params *CreateIndexForModelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/create-for-model")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDeleteIndexRequest generates requests for DeleteIndex
func NewDeleteIndexRequest(server string, indexName string, params *DeleteIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDescribeIndexRequest generates requests for DescribeIndex
func NewDescribeIndexRequest(server string, indexName string, params *DescribeIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewConfigureIndexRequest calls the generic ConfigureIndex builder with application/json body
func NewConfigureIndexRequest(server string, indexName string, params *ConfigureIndexParams, body ConfigureIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConfigureIndexRequestWithBody(server, indexName, params, "application/json", bodyReader)
}

// NewConfigureIndexRequestWithBody generates requests for ConfigureIndex with any type of body
func NewConfigureIndexRequestWithBody(server string, indexName string, params *ConfigureIndexParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewListIndexBackupsRequest generates requests for ListIndexBackups
func NewListIndexBackupsRequest(server string, indexName string, params *ListIndexBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewCreateBackupRequest calls the generic CreateBackup builder with application/json body
func NewCreateBackupRequest(server string, indexName string, params *CreateBackupParams, body CreateBackupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackupRequestWithBody(server, indexName, params, "application/json", bodyReader)
}

// NewCreateBackupRequestWithBody generates requests for CreateBackup with any type of body
func NewCreateBackupRequestWithBody(server string, indexName string, params *CreateBackupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index_name", runtime.ParamLocationPath, indexName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/indexes/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewListRestoreJobsRequest generates requests for ListRestoreJobs
func NewListRestoreJobsRequest(server string, params *ListRestoreJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

// NewDescribeRestoreJobRequest generates requests for DescribeRestoreJob
func NewDescribeRestoreJobRequest(server string, jobId string, params *DescribeRestoreJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/restore-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Pinecone-Api-Version", runtime.ParamLocationHeader, params.XPineconeApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Pinecone-Api-Version", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListProjectBackupsWithResponse request
	ListProjectBackupsWithResponse(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectBackupsResponse, error)

	// DeleteBackupWithResponse request
	DeleteBackupWithResponse(ctx context.Context, backupId string, params *DeleteBackupParams, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error)

	// DescribeBackupWithResponse request
	DescribeBackupWithResponse(ctx context.Context, backupId string, params *DescribeBackupParams, reqEditors ...RequestEditorFn) (*DescribeBackupResponse, error)

	// CreateIndexFromBackupOperationWithBodyWithResponse request with any body
	CreateIndexFromBackupOperationWithBodyWithResponse(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error)

	CreateIndexFromBackupOperationWithResponse(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error)

	// ListCollectionsWithResponse request
	ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error)

	// CreateCollectionWithBodyWithResponse request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// DeleteCollectionWithResponse request
	DeleteCollectionWithResponse(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error)

	// DescribeCollectionWithResponse request
	DescribeCollectionWithResponse(ctx context.Context, collectionName string, params *DescribeCollectionParams, reqEditors ...RequestEditorFn) (*DescribeCollectionResponse, error)

	// ListIndexesWithResponse request
	ListIndexesWithResponse(ctx context.Context, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error)

	// CreateIndexWithBodyWithResponse request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// CreateIndexForModelWithBodyWithResponse request with any body
	CreateIndexForModelWithBodyWithResponse(ctx context.Context, params *CreateIndexForModelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error)

	CreateIndexForModelWithResponse(ctx context.Context, params *CreateIndexForModelParams, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error)

	// DeleteIndexWithResponse request
	DeleteIndexWithResponse(ctx context.Context, indexName string, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// DescribeIndexWithResponse request
	DescribeIndexWithResponse(ctx context.Context, indexName string, params *DescribeIndexParams, reqEditors ...RequestEditorFn) (*DescribeIndexResponse, error)

	// ConfigureIndexWithBodyWithResponse request with any body
	ConfigureIndexWithBodyWithResponse(ctx context.Context, indexName string, params *ConfigureIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error)

	ConfigureIndexWithResponse(ctx context.Context, indexName string, params *ConfigureIndexParams, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error)

	// ListIndexBackupsWithResponse request
	ListIndexBackupsWithResponse(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*ListIndexBackupsResponse, error)

	// CreateBackupWithBodyWithResponse request with any body
	CreateBackupWithBodyWithResponse(ctx context.Context, indexName string, params *CreateBackupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	CreateBackupWithResponse(ctx context.Context, indexName string, params *CreateBackupParams, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error)

	// ListRestoreJobsWithResponse request
	ListRestoreJobsWithResponse(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*ListRestoreJobsResponse, error)

	// DescribeRestoreJobWithResponse request
	DescribeRestoreJobWithResponse(ctx context.Context, jobId string, params *DescribeRestoreJobParams, reqEditors ...RequestEditorFn) (*DescribeRestoreJobResponse, error)
}

type ListProjectBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListProjectBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON412      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexFromBackupOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateIndexFromBackupResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexFromBackupOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexFromBackupOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CollectionModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexForModelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON409      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateIndexForModelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexForModelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON412      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigureIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *IndexModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ConfigureIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigureIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIndexBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackupList
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIndexBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIndexBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BackupModel
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON402      *ErrorResponse
	JSON403      *ErrorResponse
	JSON422      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRestoreJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestoreJobList
	JSON401      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListRestoreJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRestoreJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeRestoreJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RestoreJobModel
	JSON401      *ErrorResponse
	JSON404      *ErrorResponse
	JSON500      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DescribeRestoreJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeRestoreJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListProjectBackupsWithResponse request returning *ListProjectBackupsResponse
func (c *ClientWithResponses) ListProjectBackupsWithResponse(ctx context.Context, params *ListProjectBackupsParams, reqEditors ...RequestEditorFn) (*ListProjectBackupsResponse, error) {
	rsp, err := c.ListProjectBackups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectBackupsResponse(rsp)
}

// DeleteBackupWithResponse request returning *DeleteBackupResponse
func (c *ClientWithResponses) DeleteBackupWithResponse(ctx context.Context, backupId string, params *DeleteBackupParams, reqEditors ...RequestEditorFn) (*DeleteBackupResponse, error) {
	rsp, err := c.DeleteBackup(ctx, backupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackupResponse(rsp)
}

// DescribeBackupWithResponse request returning *DescribeBackupResponse
func (c *ClientWithResponses) DescribeBackupWithResponse(ctx context.Context, backupId string, params *DescribeBackupParams, reqEditors ...RequestEditorFn) (*DescribeBackupResponse, error) {
	rsp, err := c.DescribeBackup(ctx, backupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeBackupResponse(rsp)
}

// CreateIndexFromBackupOperationWithBodyWithResponse request with arbitrary body returning *CreateIndexFromBackupOperationResponse
func (c *ClientWithResponses) CreateIndexFromBackupOperationWithBodyWithResponse(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error) {
	rsp, err := c.CreateIndexFromBackupOperationWithBody(ctx, backupId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexFromBackupOperationResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexFromBackupOperationWithResponse(ctx context.Context, backupId string, params *CreateIndexFromBackupOperationParams, body CreateIndexFromBackupOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexFromBackupOperationResponse, error) {
	rsp, err := c.CreateIndexFromBackupOperation(ctx, backupId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexFromBackupOperationResponse(rsp)
}

// ListCollectionsWithResponse request returning *ListCollectionsResponse
func (c *ClientWithResponses) ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error) {
	rsp, err := c.ListCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionsResponse(rsp)
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, params *CreateCollectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, params *CreateCollectionParams, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// DeleteCollectionWithResponse request returning *DeleteCollectionResponse
func (c *ClientWithResponses) DeleteCollectionWithResponse(ctx context.Context, collectionName string, params *DeleteCollectionParams, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error) {
	rsp, err := c.DeleteCollection(ctx, collectionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionResponse(rsp)
}

// DescribeCollectionWithResponse request returning *DescribeCollectionResponse
func (c *ClientWithResponses) DescribeCollectionWithResponse(ctx context.Context, collectionName string, params *DescribeCollectionParams, reqEditors ...RequestEditorFn) (*DescribeCollectionResponse, error) {
	rsp, err := c.DescribeCollection(ctx, collectionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeCollectionResponse(rsp)
}

// ListIndexesWithResponse request returning *ListIndexesResponse
func (c *ClientWithResponses) ListIndexesWithResponse(ctx context.Context, params *ListIndexesParams, reqEditors ...RequestEditorFn) (*ListIndexesResponse, error) {
	rsp, err := c.ListIndexes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexesResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, params *CreateIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, params *CreateIndexParams, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// CreateIndexForModelWithBodyWithResponse request with arbitrary body returning *CreateIndexForModelResponse
func (c *ClientWithResponses) CreateIndexForModelWithBodyWithResponse(ctx context.Context, params *CreateIndexForModelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error) {
	rsp, err := c.CreateIndexForModelWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexForModelResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexForModelWithResponse(ctx context.Context, params *CreateIndexForModelParams, body CreateIndexForModelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexForModelResponse, error) {
	rsp, err := c.CreateIndexForModel(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexForModelResponse(rsp)
}

// DeleteIndexWithResponse request returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, indexName string, params *DeleteIndexParams, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// DescribeIndexWithResponse request returning *DescribeIndexResponse
func (c *ClientWithResponses) DescribeIndexWithResponse(ctx context.Context, indexName string, params *DescribeIndexParams, reqEditors ...RequestEditorFn) (*DescribeIndexResponse, error) {
	rsp, err := c.DescribeIndex(ctx, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeIndexResponse(rsp)
}

// ConfigureIndexWithBodyWithResponse request with arbitrary body returning *ConfigureIndexResponse
func (c *ClientWithResponses) ConfigureIndexWithBodyWithResponse(ctx context.Context, indexName string, params *ConfigureIndexParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error) {
	rsp, err := c.ConfigureIndexWithBody(ctx, indexName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureIndexResponse(rsp)
}

func (c *ClientWithResponses) ConfigureIndexWithResponse(ctx context.Context, indexName string, params *ConfigureIndexParams, body ConfigureIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*ConfigureIndexResponse, error) {
	rsp, err := c.ConfigureIndex(ctx, indexName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigureIndexResponse(rsp)
}

// ListIndexBackupsWithResponse request returning *ListIndexBackupsResponse
func (c *ClientWithResponses) ListIndexBackupsWithResponse(ctx context.Context, indexName string, params *ListIndexBackupsParams, reqEditors ...RequestEditorFn) (*ListIndexBackupsResponse, error) {
	rsp, err := c.ListIndexBackups(ctx, indexName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIndexBackupsResponse(rsp)
}

// CreateBackupWithBodyWithResponse request with arbitrary body returning *CreateBackupResponse
func (c *ClientWithResponses) CreateBackupWithBodyWithResponse(ctx context.Context, indexName string, params *CreateBackupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackupWithBody(ctx, indexName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

func (c *ClientWithResponses) CreateBackupWithResponse(ctx context.Context, indexName string, params *CreateBackupParams, body CreateBackupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackupResponse, error) {
	rsp, err := c.CreateBackup(ctx, indexName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResponse(rsp)
}

// ListRestoreJobsWithResponse request returning *ListRestoreJobsResponse
func (c *ClientWithResponses) ListRestoreJobsWithResponse(ctx context.Context, params *ListRestoreJobsParams, reqEditors ...RequestEditorFn) (*ListRestoreJobsResponse, error) {
	rsp, err := c.ListRestoreJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRestoreJobsResponse(rsp)
}

// DescribeRestoreJobWithResponse request returning *DescribeRestoreJobResponse
func (c *ClientWithResponses) DescribeRestoreJobWithResponse(ctx context.Context, jobId string, params *DescribeRestoreJobParams, reqEditors ...RequestEditorFn) (*DescribeRestoreJobResponse, error) {
	rsp, err := c.DescribeRestoreJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeRestoreJobResponse(rsp)
}

// ParseListProjectBackupsResponse parses an HTTP response from a ListProjectBackupsWithResponse call
func ParseListProjectBackupsResponse(rsp *http.Response) (*ListProjectBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBackupResponse parses an HTTP response from a DeleteBackupWithResponse call
func ParseDeleteBackupResponse(rsp *http.Response) (*DeleteBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeBackupResponse parses an HTTP response from a DescribeBackupWithResponse call
func ParseDescribeBackupResponse(rsp *http.Response) (*DescribeBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexFromBackupOperationResponse parses an HTTP response from a CreateIndexFromBackupOperationWithResponse call
func ParseCreateIndexFromBackupOperationResponse(rsp *http.Response) (*CreateIndexFromBackupOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexFromBackupOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateIndexFromBackupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListCollectionsResponse parses an HTTP response from a ListCollectionsWithResponse call
func ParseListCollectionsResponse(rsp *http.Response) (*ListCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CollectionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionResponse parses an HTTP response from a DeleteCollectionWithResponse call
func ParseDeleteCollectionResponse(rsp *http.Response) (*DeleteCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeCollectionResponse parses an HTTP response from a DescribeCollectionWithResponse call
func ParseDescribeCollectionResponse(rsp *http.Response) (*DescribeCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexesResponse parses an HTTP response from a ListIndexesWithResponse call
func ParseListIndexesResponse(rsp *http.Response) (*ListIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexForModelResponse parses an HTTP response from a CreateIndexForModelWithResponse call
func ParseCreateIndexForModelResponse(rsp *http.Response) (*CreateIndexForModelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexForModelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeIndexResponse parses an HTTP response from a DescribeIndexWithResponse call
func ParseDescribeIndexResponse(rsp *http.Response) (*DescribeIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseConfigureIndexResponse parses an HTTP response from a ConfigureIndexWithResponse call
func ParseConfigureIndexResponse(rsp *http.Response) (*ConfigureIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigureIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest IndexModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListIndexBackupsResponse parses an HTTP response from a ListIndexBackupsWithResponse call
func ParseListIndexBackupsResponse(rsp *http.Response) (*ListIndexBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIndexBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateBackupResponse parses an HTTP response from a CreateBackupWithResponse call
func ParseCreateBackupResponse(rsp *http.Response) (*CreateBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BackupModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListRestoreJobsResponse parses an HTTP response from a ListRestoreJobsWithResponse call
func ParseListRestoreJobsResponse(rsp *http.Response) (*ListRestoreJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRestoreJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestoreJobList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDescribeRestoreJobResponse parses an HTTP response from a DescribeRestoreJobWithResponse call
func ParseDescribeRestoreJobResponse(rsp *http.Response) (*DescribeRestoreJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeRestoreJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RestoreJobModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
