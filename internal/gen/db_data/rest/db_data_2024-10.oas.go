// Package db_data provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package db_data

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ImportErrorModeOnError.
const (
	Abort    ImportErrorModeOnError = "abort"
	Continue ImportErrorModeOnError = "continue"
)

// Defines values for ImportModelStatus.
const (
	Cancelled  ImportModelStatus = "Cancelled"
	Completed  ImportModelStatus = "Completed"
	Failed     ImportModelStatus = "Failed"
	InProgress ImportModelStatus = "InProgress"
	Pending    ImportModelStatus = "Pending"
)

// CancelImportResponse The response for the `cancel_import` operation.
type CancelImportResponse = map[string]interface{}

// DeleteRequest The request for the `delete` operation.
type DeleteRequest struct {
	// DeleteAll This indicates that all vectors in the index namespace should be deleted.
	DeleteAll *bool `json:"deleteAll,omitempty"`

	// Filter If specified, the metadata filter here will be used to select the vectors to delete. This is mutually exclusive with specifying ids to delete in the ids param or using delete_all=True. See [Filter with metadata](https://docs.pinecone.io/guides/data/filter-with-metadata).
	// Serverless indexes do not support delete by metadata. Instead, you can use the `list` operation to fetch the vector IDs based on their common ID prefix and then delete the records by ID.
	Filter *map[string]interface{} `json:"filter,omitempty"`

	// Ids Vectors to delete.
	Ids *[]string `json:"ids,omitempty"`

	// Namespace The namespace to delete vectors from, if applicable.
	Namespace *string `json:"namespace,omitempty"`
}

// DeleteResponse The response for the `delete` operation.
type DeleteResponse = map[string]interface{}

// DescribeIndexStatsRequest The request for the `describe_index_stats` operation.
type DescribeIndexStatsRequest struct {
	// Filter If this parameter is present, the operation only returns statistics for vectors that satisfy the filter. See [Filter with metadata](https://docs.pinecone.io/guides/data/filter-with-metadata).
	//
	// Serverless indexes do not support filtering `describe_index_stats` by metadata.
	Filter *map[string]interface{} `json:"filter,omitempty"`
}

// FetchResponse The response for the `fetch` operation.
type FetchResponse struct {
	// Namespace The namespace of the vectors.
	Namespace *string            `json:"namespace,omitempty"`
	Usage     *Usage             `json:"usage,omitempty"`
	Vectors   *map[string]Vector `json:"vectors,omitempty"`
}

// ImportErrorMode Indicates how to respond to errors during the import process.
type ImportErrorMode struct {
	// OnError Indicates how to respond to errors during the import process.
	OnError *ImportErrorModeOnError `json:"onError,omitempty"`
}

// ImportErrorModeOnError Indicates how to respond to errors during the import process.
type ImportErrorModeOnError string

// ImportModel The model for an import operation.
type ImportModel struct {
	// CreatedAt The start time of the import operation.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Error The error message if the import process failed.
	Error *string `json:"error,omitempty"`

	// FinishedAt The end time of the import operation.
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// Id Unique identifier for the import operation.
	Id *string `json:"id,omitempty"`

	// PercentComplete The progress made by the operation out of 100
	PercentComplete *float32 `json:"percentComplete,omitempty"`

	// RecordsImported The number of records successfully imported.
	RecordsImported *int64 `json:"recordsImported,omitempty"`

	// Status The status of the operation.
	Status *ImportModelStatus `json:"status,omitempty"`

	// Uri The URI from where the data is imported.
	Uri *string `json:"uri,omitempty"`
}

// ImportModelStatus The status of the operation.
type ImportModelStatus string

// IndexDescription The response for the `describe_index_stats` operation.
type IndexDescription struct {
	// Dimension The dimension of the indexed vectors.
	Dimension *int64 `json:"dimension,omitempty"`

	// IndexFullness The fullness of the index, regardless of whether a metadata filter expression was passed. The granularity of this metric is 10%.
	//
	// Serverless indexes scale automatically as needed, so index fullness  is relevant only for pod-based indexes.
	//
	// The index fullness result may be inaccurate during pod resizing; to get the status of a pod resizing process, use [`describe_index`](https://docs.pinecone.io/reference/api/control-plane/describe_index).
	IndexFullness *float32 `json:"indexFullness,omitempty"`

	// Namespaces A mapping for each namespace in the index from the namespace name to a summary of its contents. If a metadata filter expression is present, the summary will reflect only vectors matching that expression.
	Namespaces *map[string]NamespaceSummary `json:"namespaces,omitempty"`

	// TotalVectorCount The total number of vectors in the index, regardless of whether a metadata filter expression was passed
	TotalVectorCount *int64 `json:"totalVectorCount,omitempty"`
}

// ListImportsResponse The response for the `list_imports` operation.
type ListImportsResponse struct {
	Data       *[]ImportModel `json:"data,omitempty"`
	Pagination *Pagination    `json:"pagination,omitempty"`
}

// ListItem defines model for ListItem.
type ListItem struct {
	Id *string `json:"id,omitempty"`
}

// ListResponse The response for the `list` operation.
type ListResponse struct {
	// Namespace The namespace of the vectors.
	Namespace  *string     `json:"namespace,omitempty"`
	Pagination *Pagination `json:"pagination,omitempty"`
	Usage      *Usage      `json:"usage,omitempty"`
	Vectors    *[]ListItem `json:"vectors,omitempty"`
}

// NamespaceSummary A summary of the contents of a namespace.
type NamespaceSummary struct {
	// VectorCount The number of vectors stored in this namespace. Note that updates to this field may lag behind updates to the underlying index and corresponding query results, etc.
	VectorCount *int64 `json:"vectorCount,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	Next *string `json:"next,omitempty"`
}

// QueryRequest The request for the `query` operation.
type QueryRequest struct {
	// Filter The filter to apply. You can use vector metadata to limit your search. See [Filter with metadata](https://docs.pinecone.io/guides/data/filter-with-metadata).
	Filter *map[string]interface{} `json:"filter,omitempty"`

	// Id The unique ID of the vector to be used as a query vector. Each `query` request can contain only one of the parameters `queries`, `vector`, or  `id`.
	Id *string `json:"id,omitempty"`

	// IncludeMetadata Indicates whether metadata is included in the response as well as the ids.
	IncludeMetadata *bool `json:"includeMetadata,omitempty"`

	// IncludeValues Indicates whether vector values are included in the response.
	IncludeValues *bool `json:"includeValues,omitempty"`

	// Namespace The namespace to query.
	Namespace *string `json:"namespace,omitempty"`

	// Queries DEPRECATED. The query vectors. Each `query()` request can contain only one of the parameters `queries`, `vector`, or  `id`.
	// Deprecated:
	Queries *[]QueryVector `json:"queries,omitempty"`

	// SparseVector Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
	SparseVector *SparseValues `json:"sparseVector,omitempty"`

	// TopK The number of results to return for each query.
	TopK int64 `json:"topK"`

	// Vector The query vector. This should be the same length as the dimension of the index being queried. Each `query` request can contain only one of the parameters `id` or `vector`.
	Vector *[]float32 `json:"vector,omitempty"`
}

// QueryResponse The response for the `query` operation. These are the matches found for a particular query vector. The matches are ordered from most similar to least similar.
type QueryResponse struct {
	// Matches The matches for the vectors.
	Matches *[]ScoredVector `json:"matches,omitempty"`

	// Namespace The namespace for the vectors.
	Namespace *string `json:"namespace,omitempty"`

	// Results DEPRECATED. The results of each query. The order is the same as `QueryRequest.queries`.
	// Deprecated:
	Results *[]SingleQueryResults `json:"results,omitempty"`
	Usage   *Usage                `json:"usage,omitempty"`
}

// QueryVector A single query vector within a `QueryRequest`.
type QueryVector struct {
	// Filter An override for the metadata filter to apply. This replaces the request-level filter.
	Filter *map[string]interface{} `json:"filter,omitempty"`

	// Namespace An override the namespace to search.
	Namespace *string `json:"namespace,omitempty"`

	// SparseValues Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
	SparseValues *SparseValues `json:"sparseValues,omitempty"`

	// TopK An override for the number of results to return for this query vector.
	TopK *int64 `json:"topK,omitempty"`

	// Values The query vector values. This should be the same length as the dimension of the index being queried.
	Values []float32 `json:"values"`
}

// ScoredVector defines model for ScoredVector.
type ScoredVector struct {
	// Id This is the vector's unique id.
	Id string `json:"id"`

	// Metadata This is the metadata, if it is requested.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Score This is a measure of similarity between this vector and the query vector.  The higher the score, the more they are similar.
	Score *float32 `json:"score,omitempty"`

	// SparseValues Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
	SparseValues *SparseValues `json:"sparseValues,omitempty"`

	// Values This is the vector data, if it is requested.
	Values *[]float32 `json:"values,omitempty"`
}

// SingleQueryResults defines model for SingleQueryResults.
type SingleQueryResults struct {
	// Matches The matches for the vectors.
	Matches *[]ScoredVector `json:"matches,omitempty"`

	// Namespace The namespace for the vectors.
	Namespace *string `json:"namespace,omitempty"`
}

// SparseValues Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
type SparseValues struct {
	// Indices The indices of the sparse data.
	Indices []int64 `json:"indices"`

	// Values The corresponding values of the sparse data, which must be with the same length as the indices.
	Values []float32 `json:"values"`
}

// StartImportRequest The request for the `start_import` operation.
type StartImportRequest struct {
	// ErrorMode Indicates how to respond to errors during the import process.
	ErrorMode *ImportErrorMode `json:"errorMode,omitempty"`

	// IntegrationId The id of the storage integration that should be used to access the data.
	IntegrationId *string `json:"integrationId,omitempty"`

	// Uri The URI prefix under which the data to import is available. All data within this prefix will be listed then imported into the target index. Currently only `s3://` URIs are supported.
	Uri *string `json:"uri,omitempty"`
}

// StartImportResponse The response for the `start_import` operation.
type StartImportResponse struct {
	// Id Unique identifier for the import operations.
	Id *string `json:"id,omitempty"`
}

// UpdateRequest The request for the `update` operation.
type UpdateRequest struct {
	// Id Vector's unique id.
	Id string `json:"id"`

	// Namespace The namespace containing the vector to update.
	Namespace *string `json:"namespace,omitempty"`

	// SetMetadata Metadata to set for the vector.
	SetMetadata *map[string]interface{} `json:"setMetadata,omitempty"`

	// SparseValues Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
	SparseValues *SparseValues `json:"sparseValues,omitempty"`

	// Values Vector data.
	Values *[]float32 `json:"values,omitempty"`
}

// UpdateResponse The response for the `update` operation.
type UpdateResponse = map[string]interface{}

// UpsertRequest The request for the `upsert` operation.
type UpsertRequest struct {
	// Namespace The namespace where you upsert vectors.
	Namespace *string `json:"namespace,omitempty"`

	// Vectors An array containing the vectors to upsert. Recommended batch limit is 100 vectors.
	Vectors []Vector `json:"vectors"`
}

// UpsertResponse The response for the `upsert` operation.
type UpsertResponse struct {
	// UpsertedCount The number of vectors upserted.
	UpsertedCount *int64 `json:"upsertedCount,omitempty"`
}

// Usage defines model for Usage.
type Usage struct {
	// ReadUnits The number of read units consumed by this operation.
	ReadUnits *int64 `json:"readUnits,omitempty"`
}

// Vector defines model for Vector.
type Vector struct {
	// Id This is the vector's unique id.
	Id string `json:"id"`

	// Metadata This is the metadata included in the request.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// SparseValues Vector sparse data. Represented as a list of indices and a list of  corresponded values, which must be with the same length.
	SparseValues *SparseValues `json:"sparseValues,omitempty"`

	// Values This is the vector data included in the request.
	Values []float32 `json:"values"`
}

// ProtobufAny defines model for protobufAny.
type ProtobufAny struct {
	TypeUrl *string `json:"typeUrl,omitempty"`
	Value   *[]byte `json:"value,omitempty"`
}

// RpcStatus defines model for rpcStatus.
type RpcStatus struct {
	Code    *int32         `json:"code,omitempty"`
	Details *[]ProtobufAny `json:"details,omitempty"`
	Message *string        `json:"message,omitempty"`
}

// ListBulkImportsParams defines parameters for ListBulkImports.
type ListBulkImportsParams struct {
	// Limit Max number of operations to return per page.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken Pagination token to continue a previous listing operation.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
}

// FetchVectorsParams defines parameters for FetchVectors.
type FetchVectorsParams struct {
	// Ids The vector IDs to fetch. Does not accept values containing spaces.
	Ids       []string `form:"ids" json:"ids"`
	Namespace *string  `form:"namespace,omitempty" json:"namespace,omitempty"`
}

// ListVectorsParams defines parameters for ListVectors.
type ListVectorsParams struct {
	// Prefix The vector IDs to fetch. Does not accept values containing spaces.
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`

	// Limit Max number of IDs to return per page.
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// PaginationToken Pagination token to continue a previous listing operation.
	PaginationToken *string `form:"paginationToken,omitempty" json:"paginationToken,omitempty"`
	Namespace       *string `form:"namespace,omitempty" json:"namespace,omitempty"`
}

// StartBulkImportJSONRequestBody defines body for StartBulkImport for application/json ContentType.
type StartBulkImportJSONRequestBody = StartImportRequest

// DescribeIndexStatsJSONRequestBody defines body for DescribeIndexStats for application/json ContentType.
type DescribeIndexStatsJSONRequestBody = DescribeIndexStatsRequest

// QueryVectorsJSONRequestBody defines body for QueryVectors for application/json ContentType.
type QueryVectorsJSONRequestBody = QueryRequest

// DeleteVectorsJSONRequestBody defines body for DeleteVectors for application/json ContentType.
type DeleteVectorsJSONRequestBody = DeleteRequest

// UpdateVectorJSONRequestBody defines body for UpdateVector for application/json ContentType.
type UpdateVectorJSONRequestBody = UpdateRequest

// UpsertVectorsJSONRequestBody defines body for UpsertVectors for application/json ContentType.
type UpsertVectorsJSONRequestBody = UpsertRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListBulkImports request
	ListBulkImports(ctx context.Context, params *ListBulkImportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartBulkImportWithBody request with any body
	StartBulkImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartBulkImport(ctx context.Context, body StartBulkImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelBulkImport request
	CancelBulkImport(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeBulkImport request
	DescribeBulkImport(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DescribeIndexStatsWithBody request with any body
	DescribeIndexStatsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DescribeIndexStats(ctx context.Context, body DescribeIndexStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueryVectorsWithBody request with any body
	QueryVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QueryVectors(ctx context.Context, body QueryVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVectorsWithBody request with any body
	DeleteVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVectors(ctx context.Context, body DeleteVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchVectors request
	FetchVectors(ctx context.Context, params *FetchVectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVectors request
	ListVectors(ctx context.Context, params *ListVectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVectorWithBody request with any body
	UpdateVectorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVector(ctx context.Context, body UpdateVectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertVectorsWithBody request with any body
	UpsertVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpsertVectors(ctx context.Context, body UpsertVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListBulkImports(ctx context.Context, params *ListBulkImportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBulkImportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBulkImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBulkImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartBulkImport(ctx context.Context, body StartBulkImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartBulkImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelBulkImport(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelBulkImportRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeBulkImport(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeBulkImportRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeIndexStatsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeIndexStatsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DescribeIndexStats(ctx context.Context, body DescribeIndexStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDescribeIndexStatsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryVectorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueryVectors(ctx context.Context, body QueryVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueryVectorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVectorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVectors(ctx context.Context, body DeleteVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVectorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchVectors(ctx context.Context, params *FetchVectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchVectorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVectors(ctx context.Context, params *ListVectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVectorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVectorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVectorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVector(ctx context.Context, body UpdateVectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVectorRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertVectorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertVectorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertVectors(ctx context.Context, body UpsertVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertVectorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListBulkImportsRequest generates requests for ListBulkImports
func NewListBulkImportsRequest(server string, params *ListBulkImportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk/imports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartBulkImportRequest calls the generic StartBulkImport builder with application/json body
func NewStartBulkImportRequest(server string, body StartBulkImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartBulkImportRequestWithBody(server, "application/json", bodyReader)
}

// NewStartBulkImportRequestWithBody generates requests for StartBulkImport with any type of body
func NewStartBulkImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk/imports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelBulkImportRequest generates requests for CancelBulkImport
func NewCancelBulkImportRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk/imports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeBulkImportRequest generates requests for DescribeBulkImport
func NewDescribeBulkImportRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bulk/imports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDescribeIndexStatsRequest calls the generic DescribeIndexStats builder with application/json body
func NewDescribeIndexStatsRequest(server string, body DescribeIndexStatsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDescribeIndexStatsRequestWithBody(server, "application/json", bodyReader)
}

// NewDescribeIndexStatsRequestWithBody generates requests for DescribeIndexStats with any type of body
func NewDescribeIndexStatsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/describe_index_stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewQueryVectorsRequest calls the generic QueryVectors builder with application/json body
func NewQueryVectorsRequest(server string, body QueryVectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQueryVectorsRequestWithBody(server, "application/json", bodyReader)
}

// NewQueryVectorsRequestWithBody generates requests for QueryVectors with any type of body
func NewQueryVectorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVectorsRequest calls the generic DeleteVectors builder with application/json body
func NewDeleteVectorsRequest(server string, body DeleteVectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVectorsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteVectorsRequestWithBody generates requests for DeleteVectors with any type of body
func NewDeleteVectorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vectors/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchVectorsRequest generates requests for FetchVectors
func NewFetchVectorsRequest(server string, params *FetchVectorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vectors/fetch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVectorsRequest generates requests for ListVectors
func NewListVectorsRequest(server string, params *ListVectorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vectors/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "paginationToken", runtime.ParamLocationQuery, *params.PaginationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Namespace != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "namespace", runtime.ParamLocationQuery, *params.Namespace); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVectorRequest calls the generic UpdateVector builder with application/json body
func NewUpdateVectorRequest(server string, body UpdateVectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVectorRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateVectorRequestWithBody generates requests for UpdateVector with any type of body
func NewUpdateVectorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vectors/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertVectorsRequest calls the generic UpsertVectors builder with application/json body
func NewUpsertVectorsRequest(server string, body UpsertVectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertVectorsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertVectorsRequestWithBody generates requests for UpsertVectors with any type of body
func NewUpsertVectorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vectors/upsert")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListBulkImportsWithResponse request
	ListBulkImportsWithResponse(ctx context.Context, params *ListBulkImportsParams, reqEditors ...RequestEditorFn) (*ListBulkImportsResponse, error)

	// StartBulkImportWithBodyWithResponse request with any body
	StartBulkImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBulkImportResponse, error)

	StartBulkImportWithResponse(ctx context.Context, body StartBulkImportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBulkImportResponse, error)

	// CancelBulkImportWithResponse request
	CancelBulkImportWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelBulkImportResponse, error)

	// DescribeBulkImportWithResponse request
	DescribeBulkImportWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DescribeBulkImportResponse, error)

	// DescribeIndexStatsWithBodyWithResponse request with any body
	DescribeIndexStatsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeIndexStatsResponse, error)

	DescribeIndexStatsWithResponse(ctx context.Context, body DescribeIndexStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeIndexStatsResponse, error)

	// QueryVectorsWithBodyWithResponse request with any body
	QueryVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryVectorsResponse, error)

	QueryVectorsWithResponse(ctx context.Context, body QueryVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryVectorsResponse, error)

	// DeleteVectorsWithBodyWithResponse request with any body
	DeleteVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVectorsResponse, error)

	DeleteVectorsWithResponse(ctx context.Context, body DeleteVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVectorsResponse, error)

	// FetchVectorsWithResponse request
	FetchVectorsWithResponse(ctx context.Context, params *FetchVectorsParams, reqEditors ...RequestEditorFn) (*FetchVectorsResponse, error)

	// ListVectorsWithResponse request
	ListVectorsWithResponse(ctx context.Context, params *ListVectorsParams, reqEditors ...RequestEditorFn) (*ListVectorsResponse, error)

	// UpdateVectorWithBodyWithResponse request with any body
	UpdateVectorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVectorResponse, error)

	UpdateVectorWithResponse(ctx context.Context, body UpdateVectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVectorResponse, error)

	// UpsertVectorsWithBodyWithResponse request with any body
	UpsertVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertVectorsResponse, error)

	UpsertVectorsWithResponse(ctx context.Context, body UpsertVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertVectorsResponse, error)
}

type ListBulkImportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListImportsResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r ListBulkImportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBulkImportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartBulkImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartImportResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r StartBulkImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartBulkImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelBulkImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelImportResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r CancelBulkImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelBulkImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeBulkImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportModel
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r DescribeBulkImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeBulkImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DescribeIndexStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexDescription
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r DescribeIndexStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DescribeIndexStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueryVectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r QueryVectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueryVectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r DeleteVectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchVectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FetchResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r FetchVectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r ListVectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r UpdateVectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertVectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpsertResponse
	JSON400      *RpcStatus
	JSON4XX      *RpcStatus
	JSON5XX      *RpcStatus
}

// Status returns HTTPResponse.Status
func (r UpsertVectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertVectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListBulkImportsWithResponse request returning *ListBulkImportsResponse
func (c *ClientWithResponses) ListBulkImportsWithResponse(ctx context.Context, params *ListBulkImportsParams, reqEditors ...RequestEditorFn) (*ListBulkImportsResponse, error) {
	rsp, err := c.ListBulkImports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBulkImportsResponse(rsp)
}

// StartBulkImportWithBodyWithResponse request with arbitrary body returning *StartBulkImportResponse
func (c *ClientWithResponses) StartBulkImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartBulkImportResponse, error) {
	rsp, err := c.StartBulkImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBulkImportResponse(rsp)
}

func (c *ClientWithResponses) StartBulkImportWithResponse(ctx context.Context, body StartBulkImportJSONRequestBody, reqEditors ...RequestEditorFn) (*StartBulkImportResponse, error) {
	rsp, err := c.StartBulkImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartBulkImportResponse(rsp)
}

// CancelBulkImportWithResponse request returning *CancelBulkImportResponse
func (c *ClientWithResponses) CancelBulkImportWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CancelBulkImportResponse, error) {
	rsp, err := c.CancelBulkImport(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelBulkImportResponse(rsp)
}

// DescribeBulkImportWithResponse request returning *DescribeBulkImportResponse
func (c *ClientWithResponses) DescribeBulkImportWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DescribeBulkImportResponse, error) {
	rsp, err := c.DescribeBulkImport(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeBulkImportResponse(rsp)
}

// DescribeIndexStatsWithBodyWithResponse request with arbitrary body returning *DescribeIndexStatsResponse
func (c *ClientWithResponses) DescribeIndexStatsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DescribeIndexStatsResponse, error) {
	rsp, err := c.DescribeIndexStatsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeIndexStatsResponse(rsp)
}

func (c *ClientWithResponses) DescribeIndexStatsWithResponse(ctx context.Context, body DescribeIndexStatsJSONRequestBody, reqEditors ...RequestEditorFn) (*DescribeIndexStatsResponse, error) {
	rsp, err := c.DescribeIndexStats(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDescribeIndexStatsResponse(rsp)
}

// QueryVectorsWithBodyWithResponse request with arbitrary body returning *QueryVectorsResponse
func (c *ClientWithResponses) QueryVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QueryVectorsResponse, error) {
	rsp, err := c.QueryVectorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryVectorsResponse(rsp)
}

func (c *ClientWithResponses) QueryVectorsWithResponse(ctx context.Context, body QueryVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*QueryVectorsResponse, error) {
	rsp, err := c.QueryVectors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueryVectorsResponse(rsp)
}

// DeleteVectorsWithBodyWithResponse request with arbitrary body returning *DeleteVectorsResponse
func (c *ClientWithResponses) DeleteVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVectorsResponse, error) {
	rsp, err := c.DeleteVectorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVectorsResponse(rsp)
}

func (c *ClientWithResponses) DeleteVectorsWithResponse(ctx context.Context, body DeleteVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVectorsResponse, error) {
	rsp, err := c.DeleteVectors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVectorsResponse(rsp)
}

// FetchVectorsWithResponse request returning *FetchVectorsResponse
func (c *ClientWithResponses) FetchVectorsWithResponse(ctx context.Context, params *FetchVectorsParams, reqEditors ...RequestEditorFn) (*FetchVectorsResponse, error) {
	rsp, err := c.FetchVectors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchVectorsResponse(rsp)
}

// ListVectorsWithResponse request returning *ListVectorsResponse
func (c *ClientWithResponses) ListVectorsWithResponse(ctx context.Context, params *ListVectorsParams, reqEditors ...RequestEditorFn) (*ListVectorsResponse, error) {
	rsp, err := c.ListVectors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVectorsResponse(rsp)
}

// UpdateVectorWithBodyWithResponse request with arbitrary body returning *UpdateVectorResponse
func (c *ClientWithResponses) UpdateVectorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVectorResponse, error) {
	rsp, err := c.UpdateVectorWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVectorResponse(rsp)
}

func (c *ClientWithResponses) UpdateVectorWithResponse(ctx context.Context, body UpdateVectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVectorResponse, error) {
	rsp, err := c.UpdateVector(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVectorResponse(rsp)
}

// UpsertVectorsWithBodyWithResponse request with arbitrary body returning *UpsertVectorsResponse
func (c *ClientWithResponses) UpsertVectorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertVectorsResponse, error) {
	rsp, err := c.UpsertVectorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertVectorsResponse(rsp)
}

func (c *ClientWithResponses) UpsertVectorsWithResponse(ctx context.Context, body UpsertVectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertVectorsResponse, error) {
	rsp, err := c.UpsertVectors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertVectorsResponse(rsp)
}

// ParseListBulkImportsResponse parses an HTTP response from a ListBulkImportsWithResponse call
func ParseListBulkImportsResponse(rsp *http.Response) (*ListBulkImportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBulkImportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListImportsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseStartBulkImportResponse parses an HTTP response from a StartBulkImportWithResponse call
func ParseStartBulkImportResponse(rsp *http.Response) (*StartBulkImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartBulkImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseCancelBulkImportResponse parses an HTTP response from a CancelBulkImportWithResponse call
func ParseCancelBulkImportResponse(rsp *http.Response) (*CancelBulkImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelBulkImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDescribeBulkImportResponse parses an HTTP response from a DescribeBulkImportWithResponse call
func ParseDescribeBulkImportResponse(rsp *http.Response) (*DescribeBulkImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeBulkImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDescribeIndexStatsResponse parses an HTTP response from a DescribeIndexStatsWithResponse call
func ParseDescribeIndexStatsResponse(rsp *http.Response) (*DescribeIndexStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DescribeIndexStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexDescription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseQueryVectorsResponse parses an HTTP response from a QueryVectorsWithResponse call
func ParseQueryVectorsResponse(rsp *http.Response) (*QueryVectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueryVectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseDeleteVectorsResponse parses an HTTP response from a DeleteVectorsWithResponse call
func ParseDeleteVectorsResponse(rsp *http.Response) (*DeleteVectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseFetchVectorsResponse parses an HTTP response from a FetchVectorsWithResponse call
func ParseFetchVectorsResponse(rsp *http.Response) (*FetchVectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchVectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FetchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseListVectorsResponse parses an HTTP response from a ListVectorsWithResponse call
func ParseListVectorsResponse(rsp *http.Response) (*ListVectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpdateVectorResponse parses an HTTP response from a UpdateVectorWithResponse call
func ParseUpdateVectorResponse(rsp *http.Response) (*UpdateVectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseUpsertVectorsResponse parses an HTTP response from a UpsertVectorsWithResponse call
func ParseUpsertVectorsResponse(rsp *http.Response) (*UpsertVectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertVectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpsertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 4:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON4XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest RpcStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
